<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Sp(act)rum</title>
    <link>https://sherry-long.github.io/post/</link>
    <description>Recent content in Posts on Sp(act)rum</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Jan 2021 09:48:38 +0800</lastBuildDate><atom:link href="https://sherry-long.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>红黑树 &amp; C语言实现插入</title>
      <link>https://sherry-long.github.io/post/rbtree/</link>
      <pubDate>Sun, 31 Jan 2021 09:48:38 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/rbtree/</guid>
      <description>红黑树是树型结构中难度比较高的一种，面试当中也频频出现相关问题，从JDK的Hashmap到手撕红黑树，所以深入了解红黑树还是有必要的。红黑树是一种自平衡的二叉排序树，每当它的结构发生改变时(插入或删除)，如果破坏了红黑树的性质，它就会通过变色、旋转操作来调整结构重新达到平衡。红黑树的性质：
 1.每个节点都有颜色，不是红的就是黑的 2.根节点为黑色 3.红节点的孩子必为黑节点(不会出现两个连续的红节点) 4.任一结点不管通过什么路径，到达叶子节点的黑结点数目一定相同 5.叶子节点一定为颜色为黑色的NIL节点  红黑树插入：
 首先，红黑树是一种二叉排序树，所以先按照二叉排序树的插入方法进行插入 插入后将节点颜色着成红色(否则会违背 性质4 ，少违背一条性质就意味着我们待会处理的事情越少) 这时若依然违背性质，就对红黑树的结构进行调整重新达成平衡  左旋和右旋：
旋转分为左旋和右旋，当对一个节点进行左旋时，意味着将该结点将成为它右孩子的左孩子，同样的，右旋意味着该节点将成为它左孩子的右孩子
代码实现：
void leftRotate(RBtree *t, Node *p){ //左旋函数  Node *s = p-&amp;gt;r_child; //将s指向待调整节点的右孩子  p-&amp;gt;r_child = s-&amp;gt;l_child; //s的左孩子成为p的右孩子  if(s-&amp;gt;l_child != t-&amp;gt;NIL) s-&amp;gt;l_child-&amp;gt;parent = p; //如果s的左孩子不是NIL节点(s的左孩子存在)，遂改该节点的父节点为p  s-&amp;gt;parent = p-&amp;gt;parent; // 接下来调整s取代p的位置  if(p-&amp;gt;parent == t-&amp;gt;NIL) t-&amp;gt;root = s; //如果p为根节点，s成为根节点  else if(p == p-&amp;gt;parent-&amp;gt;l_child) p-&amp;gt;parent-&amp;gt;l_child = s; //如果p为其父节点的左孩子，s取代其位置  else p-&amp;gt;parent-&amp;gt;r_child = s; //如果p为其父节点的右孩子，s取代其位置  s-&amp;gt;l_child = p; //p成为s的左孩子  p-&amp;gt;parent = s; //s成为p的父节点 } void rightRotate(RBtree *t, Node *p){ //右旋函数，过程与左旋类似，方向相反  Node *s = p-&amp;gt;l_child; p-&amp;gt;l_child = s-&amp;gt;r_child; if(s-&amp;gt;r_child !</description>
    </item>
    
    <item>
      <title>二叉排序树 &amp; c语言实现</title>
      <link>https://sherry-long.github.io/post/bstree/</link>
      <pubDate>Fri, 29 Jan 2021 11:12:54 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/bstree/</guid>
      <description>二叉排序树，又称为二叉查找树，具有以下性质： (1)若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； (2)若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值； (3)它的左、右子树也分别为二叉排序树。  根据这些性质我们可以知道，一棵二叉排序树的中序遍历序列一定是有序且升序的。插入:
1.插入过程比较简单，首先判断当前要插入的值是否已经存在二叉排序树中，如果已经存在，则直接返回；如果不存在，则转2;
2.当前要插入的值不存在，则应找到适当的位置，将其插入。注意插入的新节点一定是叶子节点;
查找:
按以下逻辑进行递归查找while(该节点不为空 &amp;amp;&amp;amp; 该节点值 != 插入值){ if(该节点值 &amp;lt; 插入值) 查找他的右子树 else if(节点值 &amp;gt; 插入值) 查找他的左子树 } 实现:
typedef struct BiTNode{ int data; struct BiTNode *l_child,*r_child; }BiTNode,*BiTree; //定义数据结构  void InOrder(BiTNode *p) //中序遍历 { if(p != NULL) { InOrder(p-&amp;gt;l_child); printf(&amp;#34; %d &amp;#34;,p-&amp;gt;data); InOrder(p-&amp;gt;r_child); } } BiTNode *createNode(int key) //建立新结点并返回 { BiTNode *temp = (BiTNode *)malloc(sizeof(BiTNode)); temp-&amp;gt;data = key; temp-&amp;gt;l_child = temp-&amp;gt;r_child = NULL; return temp; } bool BST_search(BiTNode *bst, int key, BiTNode *before, BiTree *p) //查找 { if (!</description>
    </item>
    
    <item>
      <title>动态规划-最长公共子序列</title>
      <link>https://sherry-long.github.io/post/lcs/</link>
      <pubDate>Thu, 28 Jan 2021 12:47:54 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/lcs/</guid>
      <description>动态规划的主要思想是，将待解问题分解成很多规模更小的具有相同结构的子问题，即最优子结构，然后通过分别对这些子问题求解来解决最终问题。它与分治法的主要不同点在于，动态规划分解得到子问题往往不是互相独立的。我们会保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。接下来我们来看一个比较经典的题目，最长公共子序列问题(LCS)。 问题：给出两个字符串，求出这两个字符串的LCS。(LCS：比如对于&amp;quot;A, B, D, C, E&amp;quot;和&amp;quot;A, Y, D, E, X&amp;quot;两个串来说，他们的LCS就是&amp;quot;A, D, E&amp;quot;) 求解这一问题前我们需要深入理解一下LCS，分析一下它能不能用动态规划来解决以及用动态规划的优势在哪里。 假设对于 X[m] 和 Y[n] 两个串，我要找他们两个的LCS。先假设他们的LCS为Z，如果我们从两个串的最后一个元素看起，X.m 和 Y.n ，如果 X.m ≠ Y.n ，那么Z一定也是 X[m-1] 与 Y[n] 或 X[m] 与 Y[n-1] 的LCS 换一种说法，令X = {x1, x2, &amp;hellip;, xm}, Y = {y1, y2, &amp;hellip;, yn} 为两个序列，Z = {z1, z2, &amp;hellip;, zk} 为他们的任意LCS(之所以任意，是因为两个序列的LCS可能不止一个)1.如果xm = yn，则 zk = xm = yn 且 Z[k-1] 是 X[m-1] 和 Y[n-1] 的一个LCS 2.如果xm ≠ yn，那么 zk ≠ xm 表示 Z[k] 是 X[m-1] 和 Y[n] 的一个LCS 3.</description>
    </item>
    
    <item>
      <title>字典树 &amp; Java实现</title>
      <link>https://sherry-long.github.io/post/trietree/</link>
      <pubDate>Thu, 28 Jan 2021 10:19:57 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/trietree/</guid>
      <description>字典树：又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。它有3个基本性质：1.根节点不包含字符，除根节点外每一个节点都只包含一个字符2.从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串3.每个节点的所有子节点包含的字符都不相同以一个英文单词字典树为例，它的每个节点都有最多26个子节点，代表26个英文字母。如果不了解哈希树可以想想huffman树，当我们在找一个指令的huffman编码时，我们从 根结点出发，往下找到代表该指令的叶结点，路径上经过的节点连起来便是它的huffman编码。字典树也是类似原理，只不过huffman树每个节点有两个子节点，一个代表0、一个代表1，而字典树每个节点有26个子节点(以英文字典树为例)，我们想找一个单词时，就一个字母一个字母的 从根节点往下找，所有字母找完后检查最后一个字母是否为一个单词的结尾(isEnd标志位)，如果是就查找成功。Java实现：// 成员变量 	final static int MAX_LENGTH = 26; //最大长度  char data; //节点数据  boolean isEnd; // 从根节点到此节点所经过的路径是否构成一个完整的单词(是否是一个单词的结尾)  TreeNode[] childs; // 构造方法 	TreeNode(){ childs = new TreeNode[MAX_LENGTH]; isEnd = false; } // 成员方法 	public void createTrieTree(String str, TreeNode node){ //插入节点  char[] temp = str.toCharArray(); for(int i = 0; i &amp;lt; str.length(); ++i){ int location = temp[i] - &amp;#39;a&amp;#39;; // 将字母转成0~25的数字，方便索引  if(node.childs[location] == null){ node.</description>
    </item>
    
    <item>
      <title>计算机网络-TCP三次握手四次挥手</title>
      <link>https://sherry-long.github.io/post/net/</link>
      <pubDate>Wed, 27 Jan 2021 10:11:23 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/net/</guid>
      <description>TCP是面向连接的可靠通信协议，在两端主机进行通信前，会先建立逻辑连接，而在结束通信时会断开连接，也就是我们所说的“三次握手”，“四次挥手”
那么为什么要握手三次呢？
比较官方的回答自然是，防止确认帧丢失，导致一方误以为确认帧送达而耗费资源
这样说更容易理解：
两台主机A、B要进行通信，根据TCP协议原则，A要给B发送SYN帧请求建立连接，B收到了，那么对于B来说，B就知道了A具有发送数据的能力， 这时B给A回发ACK帧，A收到了，那么对于A来说，A此时知道了B具有接受数据和发送数据的能力。此时还有一个问题，B不知道A有没有 接受数据的能力啊，要是直接给A发数据，他收不到那我岂不是白发了。那么这时A再给B回一个ACK帧，B知道A可以接受自己发给他的数据了， 就可以解决这一问题了。
其实本质上就是防止确认帧丢失，只不过这样解释感觉更好理解
那么为什么要挥手四次呢？
比如A没有东西要发给B了，想断开连接了。A向B发送了FIN帧(第一次挥手)请求结束，但是B可能还有数据没有传完，在建立连接时，可以将SYN和ACK两个标志 一起传输，是因为确认和同步本身没冲突，但是在关闭连接时，双方不一定数据都传送完了，这时如果FIN+ACK就可能会产生问题。所以B就先告诉A，好我知道 你发完了(第二次挥手)，我确认收到了你的FIN，但是我这边还有东西要给你，所以我的FIN要待会发给你。B继续向A传输数据，最后B也发完了，B就跟A说，我 也没东西给你了，我们可以分手了(FIN，第三次挥手)，A收到后：好的，我收到了，可以分手了(ACK，第四次挥手)。
这还没完呢，挥手四次完毕后，A(发起结束方)还要继续等待2MSL(最大报文段生存时间)才能close，为什么？
以上所有都是理想状态，谁知道实际会出现什么问题，有可能最后一次ACK就丢失了呢。如果不等这段时间，那最后的确认帧要是丢失了，B等了半天也不见A的确认， 反复给A重传结束帧，A这边又早就已经进入close状态，就会白白浪费资源，这是其一。
其二，藕断丝连的道理大家都懂，双方结束了连接，在数据通路中还是有可能会残留一些数据报，这2MSL就是确保这些“丝”彻底断掉，不占用资源。
分手就要分的彻底一点，不要藕断丝连
我很喜欢我们计算机网络老师说的一句话：计网如果你抱着书硬啃，那是很难的，各种约定协议算法死记硬背很痛苦。但是这些东西都是人规定的，我们按照人 的思考方式去看一些知识的时候，会发现它们其实很合逻辑很容易理解，记起来也就没那么难了。 希望大家在以后的学习中也牢记这一点。</description>
    </item>
    
    <item>
      <title>单链表 C实现</title>
      <link>https://sherry-long.github.io/post/linkedlist/</link>
      <pubDate>Tue, 26 Jan 2021 21:23:25 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/linkedlist/</guid>
      <description>单链表
数据结构
typedef struct LinkNode{ int data; struct LinkNode *next; }LinkNode,*LinkList; 函数：
尾插：
void List_Tinsert(LinkNode *p,int num) //尾插法 { LinkNode *s = p; while (s-&amp;gt;next) s = s-&amp;gt;next; LinkNode *r = (LinkNode *)malloc(sizeof(LinkNode)); r-&amp;gt;data = num; r-&amp;gt;next = NULL; s-&amp;gt;next = r; } 头插：
void List_Hinsert(LinkNode *p,int num) //头插法 { LinkNode *s; s = (LinkNode *)malloc(sizeof(LinkNode)); s-&amp;gt;data = num; s-&amp;gt;next = p-&amp;gt;next; p-&amp;gt;next = s; } 链表创建（从1到n按序生成）
void List_create(LinkNode *p,int n) { for(int i = 1;i &amp;lt;= n;++i) List_Tinsert(p,i); //从1到n，尾插生成  printf(&amp;#34;Creation complete!</description>
    </item>
    
    <item>
      <title>堆排序原理 &amp; C语言实现</title>
      <link>https://sherry-long.github.io/post/heapsort/</link>
      <pubDate>Tue, 26 Jan 2021 21:20:38 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/heapsort/</guid>
      <description>堆排序
首先说一下堆，它可以被视为完全二叉树，大（小）根堆即任意非根结点的值都小（大）于等于其双亲结点的值。
基本原理：建立大（小）根堆，依次将堆顶元素与堆底元素进行交换，每次交换完成后堆大小减一，重复此过程，直到数组中只剩下一个元素为止。
算法框架如下
void HeapSort(int *A,int n)	//此处预留A[0],所以参数n应为数组A的大小减1 { BuildMaxHeap(A,n);	//首先建立大根堆  for (int i = n;i &amp;gt; 1;--i) { swap(&amp;amp;A[i],&amp;amp;A[1]); HeapAdjust(A,1,i - 1); }	//每次循环将当前堆顶元素与堆底元素交换，此时堆性质可能会被破坏，  //调用HeapAdjust方法将堆重新调整有序 } 此处将A数组的第一个元素（A[0]）预留出来，后续有用 也就是说n个元素需要一个大小为n+1的数组
建立大根堆：
void BuildMaxHeap(int *A,int n) { for (int i = n / 2;i &amp;gt; 0;--i) { HeapAdjust(A,i,n); } } 很简单的几行代码，原理也很简单 学习过二叉树，我们知道：对于一个完全二叉树来说，它的最后一个节点是第 n/2（向下取整） 个节点的子节点。 比如说一个完全二叉树有五个节点，那么它的第五个节点就是第二个节点的子节点。 对以此节点为根的子树进行调整，使该子树成为堆。此后依次向前对各节点进行调整（n/2（向下取整）到1），直到根节点，使整个树成为堆。
堆调整
void HeapAdjust(int *A,int i,int n) { A[0] = A[i];	//将待调整节点值存放至A[0]中  for(int j = i * 2;j &amp;lt;= n;j *= 2)	//找到i节点的孩子节点j，并沿子节点向下调整  { if(j &amp;lt; n &amp;amp;&amp;amp; A[j] &amp;lt; A[j + 1])	//如果j有兄弟节点，并且	 j++;	//小于其兄弟节点，将j指向兄弟节点  //（也就是找到i的孩子节点中最大的那个，如果建立的是小根堆就是找到最小的那个）  if(A[j] &amp;gt; A[0]) { A[i] = A[j]; i = j; }	//如果i的孩子节点比j大，A[j]放到A[i]的位置上  //并将j作为下一个调整的节点，向下继续调整  else break;	//如果堆性质未被破坏则直接跳出循环  } A[i] = A[0];	//最终将A[i]放到它该在的地方（如堆性质未被破坏则还在原位置） } 堆排序，说白了就是将堆顶元素（最大元素）输出，将堆中的剩余元素重新调整有序，再将堆顶元素（此时为第二大元素）输出，循环此过程</description>
    </item>
    
    <item>
      <title>第二次测试</title>
      <link>https://sherry-long.github.io/post/blog2/</link>
      <pubDate>Tue, 26 Jan 2021 13:52:24 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/blog2/</guid>
      <description>this is another test</description>
    </item>
    
    <item>
      <title>测试</title>
      <link>https://sherry-long.github.io/post/blog1/</link>
      <pubDate>Tue, 26 Jan 2021 13:20:28 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/blog1/</guid>
      <description>this is a test</description>
    </item>
    
    <item>
      <title>Java笔记(持续更新)</title>
      <link>https://sherry-long.github.io/post/blog/</link>
      <pubDate>Tue, 26 Jan 2021 12:38:16 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/blog/</guid>
      <description>此笔记为本人在复习巩固Java基础时做的记录，内容很杂，持续更新中
this关键字 创建一个对象时分以下四部： 1.分配对象空间，将对象成员变量初始化为0或空 2.执行显示值的属性初始化 3.执行构造方法 4.返回对象的地址给相关变量 this 指的是“创建好的对象的地址”，在调用构造方法时，对象已被创建，在构造方法中使用this，代表“当前对象” this 用法 1. this.name = name; 避免程序二义 2. 使用this关键字调用重载的构造方法，避免初始化代码重复。 只能在构造方法中使用，只能引用一个，必须位于构造方法的第一句 （在构造器中，如果为this添加了参数列表，那么就有不同的含义。这将产生对符合此参数列表的某个构造器的明确调用） 3. this 不能用于static方法中（因为静态方法不依赖对象来进行访问，没有对象就谈不上this） 4. this 将当前对象本身作为参数传递给其他方法 5. return this; this 将当前对象作为参数返回，这样可以对一个对象进行多次操作  static关键字 当声明一个域或方法是static时，意味着这个域或方法不与包含他的那个类的任何对象关联在一起，与类相关联 方便在没有创建对象的情况下来进行调用（方法/变量） 1. static方法： 静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的 不需要对象便可通过类名进行调用（但是也可以通过对象进行调用） 2. static变量： 静态变量被所有对象共享，在内存中只有一个副本 3. static代码块： 优化程序性能（重复代码块） private static Date startDate,endDate; static{ startDate = Date.valueOf(&amp;quot;1946&amp;quot;); endDate = Date.valueOf(&amp;quot;1964&amp;quot;); } static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的 在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 构造器是static方法，它不需要对象来调用 static不会改变方法和变量的访问权限 静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够） 可用static来实现单例模式 public class New { private static New new1 = new New(); public static New getAccess(){ return new1; } public static void main(String[] args) { System.</description>
    </item>
    
  </channel>
</rss>
