<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Sp(act)rum</title>
    <link>https://sherry-long.github.io/post/</link>
    <description>Recent content in Posts on Sp(act)rum</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Mar 2023 11:28:53 +0800</lastBuildDate><atom:link href="https://sherry-long.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL高级</title>
      <link>https://sherry-long.github.io/post/mysqlpremium/</link>
      <pubDate>Sun, 05 Mar 2023 11:28:53 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/mysqlpremium/</guid>
      <description>MySQL索引
查询优化
范式
事务
  #
MySQL索引 为什么使用索引 索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录
建立索引主要目的是为了减少磁盘IO次数
 索引及其优缺点 索引是帮助MySQL高效获取数据的数据结构
索引的本质：索引是数据结构。可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法
索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度
 优点  提高数据检索的效率，降低数据库的IO成本，这也是创建索引最主要的原因 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性 在实现数据的参考完整性方面，可以加速表与表之间的连接，对于有依赖关系的子表和父表联合查询时，可以提高查询速度 在使用分组和排序子句进行数据查询时，可以显著减少查询中分组和排序的时间，降低CPU消耗   缺点 增加索引也有许多不利的方面，主要表现在如下几个方面：
 创建索引和维护索引要耗费时间 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上，如果有大量索引，索引文件可能比数据文件更快到达最大文件尺寸 虽然索引大大提高了查询速度，同时却会降低更新表的速度。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度  索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引
 InnoDB中的索引 数据库中的数据以数据页为单位进行存储，大部分情况下我们表中存放的记录是非常多的，需要好多的数据页来存储这些记录。在多数据页中查找记录分两步：
 定位记录所在页 从所在页中查找相应记录  在没有索引的情况下，由于我们不能快速定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据上面的查找方法去查找指定记录
 B+树 不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出，我们实际用户记录都在最底层节点上(叶子节点)
规定最下边一层，也就是我们存放用户记录的那层为第0层
 常见索引概念 索引按照物理实现方式，可以分为两种：聚集索引和非聚集索引。我们也把非聚集索引称为二级索引或者辅助索引
 聚集索引 聚集索引并不是一种单独的索引类型，而是一种数据存储方式(所有的用户记录都存储在了叶子节点)，也就是所谓的索引即数据，数据即索引
术语“聚集”表示数据行和相邻的键值聚集的存储在一起
特点：
 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：  页内的记录是按照主键的大小顺序排成一个单向链表 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表 存放目录项记录的页分为不同的层次，同一层次中的页也是根据页中目录项记录的逐渐大小顺序排成一个双向链表   B+树的叶子节点存储的是完整的用户记录 所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)  我们把具有这两种特点的B+树称为聚集索引，所有完整的用户记录都存放在这个聚集索引的叶子节点处。
这种聚集索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建，InnoDB存储引擎会自动为我们创建聚集索引
优点：
 数据访问更快，因为聚集索引将索引和数据保存在同一个B+树中，因此从聚集索引中获取数据比非聚集索引更快 聚集索引对于主键的排序查找和范围查找速度非常快 按照聚集索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的IO操作  缺点：</description>
    </item>
    
    <item>
      <title>MySQL初级</title>
      <link>https://sherry-long.github.io/post/mysql/</link>
      <pubDate>Tue, 21 Feb 2023 11:39:54 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/mysql/</guid>
      <description>​	SELECT
​	运算符-符号与关键字
​	ORDERBY
​	分页
​	多表查询-内连外连、UNION
​	SQL99新特性
​	单行函数
​	聚合函数与GROUPBY、HAVING
​	SQL执行流程
​	子查询
​	DDL-创建管理表
​	DCL-COMMIT、ROLLBACK
  SQL分类：
  DDL：数据定义语言。CREATE \ ALTER \ DROP \ RENAME \ TRUNCATE
  DML：数据操作语言。INSERT \ DELETE \ UPDATE \ SELECT
  DCL：数据控制语言。GRANT \ REVOKE
  TCL：事务控制语言。COMMIT \ ROLLBACK \ SAVEPOINT
    #
SELECT相关 列与表的别名 # 字段名 别名 SELECT emp_name eName FROM t_emp; # 字段名 AS 别名 （AS ~ AliaS） SELECT emp_name AS eName FROM t_emp; # 字段名 &amp;#34;别名&amp;#34; （当别名中含有 空格 时，必须使用此方法） SELECT emp_name &amp;#34;eName&amp;#34; FROM t_emp; # 表名 别名 SELECT emp_name FROM t_emp emp; # 如果给表起了别名，在SELECT和WHERE中必须使用别名，否则会报错 去重 # 只保留一个符合条件的结果 SELECT DISTINCT * FROM t_emp WHERE emp_name = &amp;#39;赵&amp;#39; 着重号 `` # 当表名或字段名与关键字发生冲突时，使用 `` 来区分 SELECT * FROM `order` 查询常数 SELECT &amp;#39;字符串&amp;#39;, 123, emp_name, age FROM t_emp 显示表结构 DESC t_emp DESCRIBE t_emp   #</description>
    </item>
    
    <item>
      <title>线程安全集合类</title>
      <link>https://sherry-long.github.io/post/threadsafecollection/</link>
      <pubDate>Sun, 19 Feb 2023 15:36:53 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/threadsafecollection/</guid>
      <description>线程安全集合类概述 线程安全集合类分为三大类：
 遗留的线程安全集合如 Hashtable, Vector 使用Collections装饰的线程安全集合  Collections.synchronizedCollection Collections.synchronizedList Collections.synchronizedMap Collections.synchronizedSet Collections.synchronizedNavigableMap Collections.synchronizedNavigableSet Collections.synchronizedSortedMap Collections.synchronizedSortedSet   java.util.concurrent.*  JUC下的线程安全集合类，包含三类关键词
 Blocking 大部分实现基于锁，并提供用来阻塞的方法 CopyOnWrite 之类的容器修改开销相对较重 Concurrent 类型的容器  内部很多操作使用CAS优化，一般可以提供较高吞吐量 弱一致性  遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 求大小弱一致性，size操作未必是 100% 准确 读取弱一致性      遍历时如果发生了修改，对于非安全容器来讲，使用fail-fast机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历
 ConcurrentHashMap  computeIfAbsent(key, Function) - 缺少 key ，计算生成一个值，键值对放入集合中  原理 - 属性&amp;amp;内部类&amp;amp;方法 // 默认为0 // 当初始化时，为 -1 // 当扩容时，为 -(1 + 扩容线程数) // 当初始化或扩容完成后，为 下一次的扩容阈值大小 private transient volatile int sizeCtl; // 整个 ConcurrentHashMap 就是一个 Node[] static class Node&amp;lt;K, V&amp;gt; implements Map.</description>
    </item>
    
    <item>
      <title>JUC原理相关</title>
      <link>https://sherry-long.github.io/post/juc/</link>
      <pubDate>Fri, 17 Feb 2023 16:49:53 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/juc/</guid>
      <description>AQS原理 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架
特点：
 用 state 属性来表示资源的状态（独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁  getState - 获取 state 状态 setState - 设置 state 状态 compareAndSetState - 乐观锁机制设置 state 状态 独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源   提供了基于FIFO的等待队列，类似于Monitor的EntryList 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor的WaitSet  子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）
 tryAcquire tryRelease tryAcquireShared tryReleaseShared isHeldExclusively  // 使用AQS自定义锁 // 自定义锁 不可重入锁 public class MyLock implements Lock { // 独占锁  class MySync extends AbstractQueuedSynchronizer { @Override protected boolean tryAcquire(int arg) { if (compareAndSetState(0, 1)){ setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } @Override protected boolean tryRelease(int arg) { setExclusiveOwnerThread(null); setState(0); return true; } @Override protected boolean isHeldExclusively() { return getState() == 1; } public Condition newCondition(){ return new ConditionObject(); } } private MySync sync = new MySync(); @Override // 加锁 不成功会进入等待队列  public void lock() { sync.</description>
    </item>
    
    <item>
      <title>Tomcat线程池</title>
      <link>https://sherry-long.github.io/post/tomcatthreadpool/</link>
      <pubDate>Fri, 17 Feb 2023 16:12:35 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/tomcatthreadpool/</guid>
      <description>Tomcat在Connector连接器组件中使用了线程池
 LimitLatch 用来限流，可以控制最大连接个数，类似juc中的Semaphore Acceptor 只负责接收新的socket连接 Poller 只负责监听 socket channel 是否有可读的I/O事件 一旦可读，封装一个任务对象(socketProcessor)，提交给Executor线程池处理 Executor线程池中的工作线程最终负责处理请求  Tomcat线程池扩展了ThreadPoolExecutor，行为稍有不同
 如果总线程数达到 maximumPoolSize  这时不会立刻抛 RejectedExecutionException 异常 而是    </description>
    </item>
    
    <item>
      <title>享元模式案例-自定义简易连接池、线程池</title>
      <link>https://sherry-long.github.io/post/flyweightinstance/</link>
      <pubDate>Thu, 16 Feb 2023 16:04:22 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/flyweightinstance/</guid>
      <description>自定义连接池
使用原子数组，无锁法(乐观锁)
public class Pool { // 连接池大小  private int poolSize; // Connection对象数组  private Connection[] connections; // 连接池状态  private AtomicIntegerArray status; public Pool(int poolSize) { this.poolSize = poolSize; this.connections = new Connection[poolSize]; this.status = new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i &amp;lt; poolSize; i++) { connections[i] = new Connection(&amp;#34;conn&amp;#34; + i); } } // 获取连接  public Connection getConnection() { while (true) { for (int i = 0; i &amp;lt; poolSize; i++) { if (status.</description>
    </item>
    
    <item>
      <title>Java线程2</title>
      <link>https://sherry-long.github.io/post/javathread1/</link>
      <pubDate>Sat, 04 Feb 2023 17:08:16 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javathread1/</guid>
      <description>守护线程 默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束
垃圾回收线程就是守护线程，在其他非守护线程结束运行后，无论有没有执行完，都立刻停止
 线程状态 操作系统层面-5层 Java层面-6层  轻量级锁 使用场景：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的(也就是没有竞争)，那么可以使用轻量级锁来优化
轻量级锁对使用者是透明的，语法仍然是synchronized
 ReentrantLock 可重入锁，synchronized也是可重入锁
特点：
 可重入&amp;ndash;持有锁的线程可以重复上锁 可打断&amp;ndash;LockInterruptibly()，在获取锁时可由其他线程使用interrupt来打断其等待状态，避免死锁，偏被动 锁超时&amp;ndash;tryLock(long timeout, TimeUnit unit)，在尝试获取锁时可以设置超时时间，超时自动放弃获取，主动打断等待状态，避免死锁 公平锁 支持多条件变量  private static ReentrantLock ROOM = new ReentrantLock(); private static Condition waitCigar = ROOM.newCondition(); private static Condition waitTakeout = ROOM.newCondition(); //wait notify所有线程都在同一个waitSet中等待唤醒 //await signal支持多个waitSet，等待不同条件的线程可以在不同的waitSet中等待  volatile 关键字，可以保证共享变量的可见性和有序性
多个线程对共享变量进行修改，要使修改对其他线程可见，使用volatile volatile还可以禁止指令重排序，jvm为了优化会进行指令重排序，可能会导致多线程环境下出现错误 操作volatile修饰的变量的代码之前的代码可以保证指令有序性
volatile原理 volatile的底层实现原理是内存屏障，Memory Barrier(Memory Fence)
 对volatile变量的写指令后会加入写屏障 对volatile变量的读指令前会加入读屏障  如何保证可见性 写屏障保证在该屏障之前的对共享变量的改动(赋值)，都同步到主存当中
读屏障保证在该屏障之后所有对于共享变量的读取，加载的是主存中的最新数据
如何保证有序性 写屏障可以保证写屏障之前的代码在指令重排时不会排到写屏障之后
读屏障可以保证读屏障之后的代码在指令重排时不会排到读屏障之前
 原子类 原子类使用乐观锁设计思想实现，内部不设锁，通过CAS + volatile来实现原子操作</description>
    </item>
    
    <item>
      <title>Redisson</title>
      <link>https://sherry-long.github.io/post/redisson/</link>
      <pubDate>Fri, 20 Jan 2023 11:06:02 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/redisson/</guid>
      <description>Redisson入门 1.引入依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.19.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.配置Redisson客户端
@Configuration public class RedisConfig { @Bean public RedissonClient redissonClient(){ // 配置类  Config config = new Config(); // 添加redis地址，这里添加了单点地址，也可以使用config.useClusterServers()添加集群地址  config.useSingleServer().setAddress(&amp;#34;redis://192.168.88.128:6379&amp;#34;).setPassword(&amp;#34;Redis&amp;#34;); // 创建客户端  return Redisson.create(config); } } </description>
    </item>
    
    <item>
      <title>Redis进阶</title>
      <link>https://sherry-long.github.io/post/redispremier/</link>
      <pubDate>Tue, 27 Dec 2022 10:53:23 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/redispremier/</guid>
      <description>缓存穿透
缓存雪崩
缓存击穿
缓存工具类封装
全局ID生成器
秒杀超卖
分布式锁
使用Lua脚本解决分布式锁的原子性问题
基于Redis的分布式锁优化-Redisson
#
缓存穿透 缓存穿透产生的原因： 用户请求的数据在redis缓存和数据库中都不存在，用户不断发起该请求，会给数据库带来巨大压力
解决方案：  缓存null值(空字符串) 布隆过滤(类似位图) 增强id的复杂度，避免被猜测id规律 做好数据的基础格式校验 加强用户权限校验 对热点参数做限流  private Shop queryWithPassThrough(Long id){ // 从redis查询商铺缓存  String shopJson = stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY + id); // 判断是否存在  if (StrUtil.isNotBlank(shopJson)) { // 存在，直接返回  return JSONUtil.toBean(shopJson, Shop.class); } // 判断命中的是否是空值  if (shopJson != null){ return null; } // 不存在，根据id查数据库  Shop shop = getById(id); // 数据库不存在，返回404  if (shop == null) { // 将空值写入redis  stringRedisTemplate.</description>
    </item>
    
    <item>
      <title>Redis基础</title>
      <link>https://sherry-long.github.io/post/redis/</link>
      <pubDate>Sun, 04 Dec 2022 17:13:26 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/redis/</guid>
      <description>一、Redis入门 1.认识NoSQL 1.1	什么是NoSQL   NoSQL最常见的解释是&amp;quot;non-relational&amp;quot;， 很多人也说它是&amp;quot;Not Only SQL&amp;quot; NoSQL仅仅是一个概念，泛指非关系型的数据库 区别于关系数据库，它们不保证关系数据的ACID特性 NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入 常见的NoSQL数据库有：Redis、MemCache、MongoDB等  1.2	NoSQL与SQL的差异      SQL NoSQL     数据结构 结构化 非结构化   数据关联 关联的 无关联的   查询方式 SQL查询 非SQL   事务特性 ACID BASE   存储方式 磁盘 内存   扩展性 垂直 水平   使用场景 1）数据结构固定
2）相关业务对数据安全性、一致性要求较高 1）数据结构不固定
2）对一致性、安全性要求不高
3）对性能要求    2.认识Redis  Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</description>
    </item>
    
    <item>
      <title>SSM整合</title>
      <link>https://sherry-long.github.io/post/ssm/</link>
      <pubDate>Thu, 01 Dec 2022 11:30:17 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/ssm/</guid>
      <description>SSM整合 4.1、ContextLoaderListener Spring提供了监听器ContextLoaderListener，实现ServletContextListener接口，可监听
ServletContext的状态，在web服务器的启动，读取Spring的配置文件，创建Spring的IOC容器。web
应用中必须在web.xml中配置
&amp;lt;listener&amp;gt; &amp;lt;!-- 配置Spring的监听器，在服务器启动时加载Spring的配置文件 Spring配置文件默认位置和名称：/WEB-INF/applicationContext.xml 可通过上下文参数自定义Spring配置文件的位置和名称 --&amp;gt; &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; &amp;lt;!--自定义Spring配置文件的位置和名称--&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath:spring.xml&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; 4.2、准备工作 ①创建Maven Module ②导入依赖 &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;spring.version&amp;gt;5.3.1&amp;lt;/spring.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--springmvc--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Mybatis核心 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.11&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>MyBatis</title>
      <link>https://sherry-long.github.io/post/mybatis/</link>
      <pubDate>Mon, 21 Nov 2022 15:22:53 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/mybatis/</guid>
      <description>​	一、MyBatis简介
​	二、搭建MyBatis
​	三、核心配置文件详解
​	四、MyBatis获取参数值的两种方式
​	五、MyBatis的各种查询功能
​	六、特殊SQL的执行
​	七、自定义映射resultMap
​	八、动态SQL
​	九、MyBatis缓存
​	十、MyBatis逆向工程
​	十一、分页插件
#
一、MyBatis简介 1. MyBatis特性   MyBatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架
  MyBatis避免了几乎所有的 JDBC代码和手动设置参数以及获取结果集
  MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录
  MyBatis 是一个半自动的ORM（Object Relation Mapping）框架
    #
二、搭建MyBatis 打包方式：jar 引入依赖 &amp;lt;!-- MySQL驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.31&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MyBatis核心 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.11&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Junit --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.</description>
    </item>
    
    <item>
      <title>SSM常用配置</title>
      <link>https://sherry-long.github.io/post/springconfig/</link>
      <pubDate>Fri, 18 Nov 2022 17:13:57 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/springconfig/</guid>
      <description>pom.xml &amp;lt;dependencies&amp;gt; &amp;lt;!-- SpringMVC --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 日志 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- ServletAPI --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- Spring5和Thymeleaf整合包 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.thymeleaf&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;thymeleaf-spring5&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.13.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 文件上传模块 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- 德鲁伊数据库连接池 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.2.15&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- jackson依赖，SpringMVC处理json需要 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.14.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MySQL驱动 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.31&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- MyBatis核心 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>RESTful-员工信息管理</title>
      <link>https://sherry-long.github.io/post/restfuldemo/</link>
      <pubDate>Sun, 13 Nov 2022 10:58:03 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/restfuldemo/</guid>
      <description>RESTful案例 功能清单    功能 URL 地址 请求方式     访问首页√ / GET   查询全部数据√ /employee GET   删除√ /employee/2 DELETE   跳转到添加数据页面√ /toAdd GET   执行保存√ /employee POST   跳转到更新数据页面√ /employee/2 GET   执行更新√ /employee PUT    访问首页 配置view-controller &amp;lt;mvc:view-controller path=&amp;#34;/&amp;#34; view-name=&amp;#34;index&amp;#34;/&amp;gt; 查询与删除 employee_list.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34; xmlns:th=&amp;#34;http://www.thymeleaf.org&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;员工信息&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;table id=&amp;#34;dataTable&amp;#34; border=&amp;#34;1&amp;#34; style=&amp;#34;text-align: center;border-spacing: 0; border-collapse: collapse&amp;#34;&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th colspan=&amp;#34;5&amp;#34;&amp;gt;员工信息&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;id&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;lastName&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;email&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;gender&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;options&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>Spring5新特性</title>
      <link>https://sherry-long.github.io/post/javaspringnewfeature/</link>
      <pubDate>Mon, 31 Oct 2022 10:28:16 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaspringnewfeature/</guid>
      <description>整个Spring5框架的代码基于Java8，运行时兼容JDK9，许多不建议使用的类和方法在代码库中删除
Spring5自带了通用的日志封装
 Spring5移除了Log4jConfigListener，官方建议使用Log4j2  Spring5中如何整合Log4j2 //引入依赖 log4j-api-2.19.0.jar log4j-core-2.19.0.jar log4j-slf4j-impl-2.19.0.jar slf4j-api-2.0.3.jar //编写配置文件，内容较为固定  &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!--日志级别以及优先级排序(越右越高)：OFF &amp;lt; FATAL &amp;lt; ERROR &amp;lt; WARN &amp;lt; INFO &amp;lt; DEBUG &amp;lt; TRACE &amp;lt; ALL--&amp;gt; &amp;lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成TRACE时，可以看到log4j2内部各种详细输出--&amp;gt; &amp;lt;Configuration xmlns=&amp;#34;http://logging.apache.org/log4j/2.0/config&amp;#34; status=&amp;#34;INFO&amp;#34;&amp;gt; &amp;lt;!--先定义所有的appender--&amp;gt; &amp;lt;Appenders&amp;gt; &amp;lt;!--输出日志信息到控制台--&amp;gt; &amp;lt;Console name=&amp;#34;Console&amp;#34; target=&amp;#34;SYSTEM_OUT &amp;#34;&amp;gt; &amp;lt;!--控制日志的输出格式--&amp;gt; &amp;lt;PatternLayout pattern=&amp;#34;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&amp;#34;/&amp;gt; &amp;lt;/Console&amp;gt; &amp;lt;/Appenders&amp;gt; &amp;lt;!--然后定义logger，只有定义了logger并引入appender，appender才会生效--&amp;gt; &amp;lt;!--root：用于指定项目的根日志，如果没有单独指定logger，则会使用root作为默认的日志输出--&amp;gt; &amp;lt;Loggers&amp;gt; &amp;lt;Root level=&amp;#34;info&amp;#34;&amp;gt; &amp;lt;AppenderRef ref=&amp;#34;Console&amp;#34;/&amp;gt; &amp;lt;/Root&amp;gt; &amp;lt;/Loggers&amp;gt; &amp;lt;/Configuration&amp;gt;   @Nullable注解和函数式注册对象   @Nullable注解可以使用在方法、属性、参数上面，表示：方法返回可以为空，属性值可以为空，参数值可以为空
  手动new的方式创建的对象不会被Spring识别，可以通过函数式风格创建对象，交给Spring管理</description>
    </item>
    
    <item>
      <title>Spring-事务</title>
      <link>https://sherry-long.github.io/post/javatransactions/</link>
      <pubDate>Fri, 28 Oct 2022 08:37:19 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javatransactions/</guid>
      <description>1）事务是数据库操作的基本单元，是逻辑上的一组操作，要么都成功，要么都失败，如果有一个操作失败所有操作都失败
2）典型场景：银行转账
目录
ACID
Spring事务管理介绍
注解声明式事务管理(Annotation)
声明式事务管理中部分参数配置(Parameters)
xml声明式事务管理
完全注解声明式事务管理(CompleteAnnotation)
事务四大特性（ACID原则） #
1）原子性（Atomicity）
 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。  2）一致性（Consistency）
 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。  3）隔离性（Isolation）
 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。  4）持久性（Durability）
 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。    事务操作（Spring事务管理介绍） #
1）事务添加到JavaEE三层结构里面的Service层（业务逻辑层）
2）在Spring中进行事务管理操作有两种方式：
  编程式事务管理（较少使用）
  声明式事务管理（主流） 分为两种：基于注解； 基于xml配置文件
  3） 在Spring中进行声明式事务管理，底层使用AOP原理
4）Spring事务管理API
//提供了一个接口，代表事务管理器，这个接口根据不同框架提供了不同实现类 |PlatformTransactionManager --|DataSourceTransactionManager //实现类 --|HibernateTransactionManager //实现类    事务操作（注解声明式事务管理） #
1）在Spring配置文件中配置事务管理器
&amp;lt;!--创建事务管理器--&amp;gt; &amp;lt;bean id=&amp;#34;transactionManager&amp;#34; class=&amp;#34;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;dataSource&amp;#34; ref=&amp;#34;dataSource&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; 2）在Spring配置文件中开启事务注解</description>
    </item>
    
    <item>
      <title>JDBC Template</title>
      <link>https://sherry-long.github.io/post/javajdbctemplate/</link>
      <pubDate>Wed, 26 Oct 2022 11:10:50 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javajdbctemplate/</guid>
      <description>JDBC Template 1）什么是JDBC Template
 Spring框架对JDBC进行了封装，使用JDBC Template可以很方便实现对数据库的操作  2）准备工作
  引入相关的依赖 druid-1.2.14.jar
mysql-connector-java-8.0.30.jar
spring-jdbc-5.3.9.jar
spring-orm-5.3.9.jar
spring-tx-5.3.9.jar
  在Spring配置文件中配置数据库连接池
  &amp;lt;bean id=&amp;#34;dataSource&amp;#34; class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;jdbc:mysql:///user_db&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34;/&amp;gt; &amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;root&amp;#34;/&amp;gt; &amp;lt;!--Loading class `com.mysql.jdbc.Driver&amp;#39;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&amp;#39;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.--&amp;gt; &amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34;/&amp;gt;&amp;lt;!--此行可注释掉--&amp;gt; &amp;lt;/bean&amp;gt;  配置JDBC Template对象，注入DataSource  &amp;lt;bean id=&amp;#34;jdbcTemplate&amp;#34; class=&amp;#34;org.</description>
    </item>
    
    <item>
      <title>AOP</title>
      <link>https://sherry-long.github.io/post/javaaop/</link>
      <pubDate>Mon, 24 Oct 2022 09:48:19 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaaop/</guid>
      <description>不通过修改源代码，在主干功能里添加新功能
目录
AOP底层原理
AOP术语
实现AOP操作
AOP操作(AspectJ注解)
AOP操作(AspectJ配置文件，了解)
AOP底层原理 #
1）AOP底层使用动态代理来实现，有两种情况
第一种 有接口，使用JDK动态代理，创建当前接口实现类的代理对象
第二种 没有接口，使用CGLIB动态代理，创建当前类子类的代理对象
 AOP（JDK动态代理） 详见 Java反射-动态代理 部分    AOP术语 #
 连接点  类里边哪些方法可以被增强（增加功能），这些方法就被称为连接点
 切入点  实际真正被增强的方法，就叫切入点
 通知（增强）  实际增强的逻辑部分，就叫通知，通知有多种类型
前置通知：在方法执行之前执行 后置通知：在方法执行之后执行 环绕通知：在方法执行之前与之后都执行 异常通知：当该方法抛出异常时执行 最终通知：无论有没有异常，都会执行  切面  是一个动作，把通知应用到切入点的过程，叫切面
  实现AOP操作 #
1）Spring框架中，一般基于AspectJ实现AOP操作
AspectJ不是Spring组成部分，是一个独立AOP框架，一般把AspectJ和Spring一起使用，进行AOP操作
2）基于AspectJ实现AOP操作有两种方式
  基于xml配置文件实现
  基于注解方式实现
  3）在项目中引入AOP依赖 spring-aop-n.n.n.RELEASE.jar com.springsource.net.* com.springsource.org.*
4）切入点表达式
作用：知道对哪个类里的哪个方法进行增强
语法结构：execution([权限修饰符] [返回类型] [类全路径] [参数列表])</description>
    </item>
    
    <item>
      <title>Spring-IoC操作 Bean管理(基于注解)</title>
      <link>https://sherry-long.github.io/post/javaspring2/</link>
      <pubDate>Fri, 21 Oct 2022 15:05:02 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaspring2/</guid>
      <description>IoC操作 Bean管理(基于注解) 使用注解的目的：简化xml配置
Spring针对Bean管理中 创建对象提供的注解 1）@Component
2）@Service（用在业务层）
3）@Controller（用在Web层）
4）@Repository（用在持久层（dao层））
上面四个注解功能是一样的，都可以用来创建bean实例   基于注解方式实现bean对象创建 1）引入依赖 spring-aop-n.n.n.RELEASE.jar
2）开启组件扫描
//配置文件引入context名称空间，开启组件扫描 &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:p=&amp;#34;http://www.springframework.org/schema/p&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;!--开启组件扫描 如果扫描多个包，使用逗号隔开 或者直接扫描这多个包的上层目录 --&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.sherry.Spring.TestDemo, 。。。&amp;#34;&amp;gt;&amp;lt;/context:component-scan&amp;gt; &amp;lt;/beans&amp;gt; 3）在类中使用注解
//注解里的value可以省略不写。默认值是首字母小写的类名 //此注解等效于使用bean标签进行配置 @Component(value = &amp;#34;userService&amp;#34;) public class UserService { public void add(){ System.out.println(&amp;#34;service add .......&amp;#34;); } } 4）开启组件扫描细节配置
&amp;lt;!--示例一 use-default-filters: 是否使用默认过滤器 context:include-filter：设置扫描哪些内容 --&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.sherry&amp;#34; use-default-filters=&amp;#34;false&amp;#34;&amp;gt; &amp;lt;context:include-filter type=&amp;#34;annotation&amp;#34; expression=&amp;#34;org.springframework.stereotype.Controller&amp;#34;/&amp;gt; &amp;lt;/context:component-scan&amp;gt; &amp;lt;!--示例一 context:exclude-filter：设置不扫描哪些内容 --&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.sherry&amp;#34;&amp;gt; &amp;lt;context:exclude-filter type=&amp;#34;annotation&amp;#34; expression=&amp;#34;org.</description>
    </item>
    
    <item>
      <title>Spring-IoC操作 Bean管理(基于xml配置文件)</title>
      <link>https://sherry-long.github.io/post/javaspring1/</link>
      <pubDate>Fri, 21 Oct 2022 15:03:31 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaspring1/</guid>
      <description>IoC操作 Bean管理(基于xml配置文件)  什么是Bean管理： Bean管理指的是两个操作：1，创建对象 2，注入属性  基于xml方式创建对象 &amp;lt;bean id=&amp;#34;user&amp;#34; class=&amp;#34;com.sherry.Spring.User&amp;#34;&amp;gt;&amp;lt;/bean&amp;gt; 在spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建 在bean标签中有很多属性，常用属性： id：唯一标识 class：类全路径（包类路径） 创建对象的时候，默认执行无参构造方法，实体类内部要么无构造方法，要么显式定义无参构造方法，否则会报错  基于xml方式注入属性 第一种注入方式：在实体类内部编写set方法，通过方法进行注入 （可以使用p名称空间进行简化）
//实体类 public class User { private String userName; private int userAge; public void setUserName(String userName) { this.userName = userName; } public void setUserAge(int userAge) { this.userAge = userAge; } public void add(){ System.out.println(&amp;#34;add .................&amp;#34;); } public void show(){ System.out.println(userName + &amp;#34;: &amp;#34; + userAge); } } //配置文件 &amp;lt;beans ...&amp;gt; &amp;lt;bean id=&amp;#34;user&amp;#34; class=&amp;#34;com.</description>
    </item>
    
    <item>
      <title>Spring5</title>
      <link>https://sherry-long.github.io/post/javaspring/</link>
      <pubDate>Wed, 12 Oct 2022 11:41:55 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaspring/</guid>
      <description>Spring框架概述 Spring框架是一个开源的J2EE应用程序框架，针对bean生命周期进行管理的轻量级容器。
Spring有两个核心部分：IoC(控制反转) 和 AOP(面向切面编程)
Spring框架主要由七部分组成：Spring Core, Spring AOP, Spring ORM, Spring DAO, Spring Context, Spring Web, Spring Web MVC
  IoC容器  什么是IoC？ 控制反转(Inversion of Control)，是一种设计原则，可以用来降低代码之间的耦合度。其中最常见的方式叫做依赖注入(Dependency Injection, DI for short)， 还有一种方式叫“依赖查找”(Dependency Lookup)。  把对象的创建和对象之间的调用过程，交给Spring进行管理。
 IoC底层原理  xml解析、工厂模式、反射  首先，在xml中配置bean，IoC会根据id，通过class的路径，使用ClassforName来创建对应的对象并返回，降低了耦合
IoC思想基于IoC容器完成，IoC容器底层就是对象工厂
  Spring提供IoC容器实现两种方式(两个接口)  IoC接口(BeanFactory) IoC容器基本实现，是Spring内部的使用接口，开发人员一般不进行使用
 加载配置文件时，不会创建对象。只有在获取对象(getBean)，或者使用对象时，才会创建对象   IoC接口(ApplicationContext，BeanFactory的子接口) BeanFactory的子接口，提供更多更强大的功能，一般由开发人员使用
ApplicationContext接口有两个实现类，ClassPathXmlApplicationContext 以及 FileSystemXmlApplicationContext
 加载配置文件时，就会把在配置文件中的对象创建  @Test public void test1(){ //通过类路径的方式加载配置文件  //ApplicationContext context = new ClassPathXmlApplicationContext(&amp;#34;bean1.</description>
    </item>
    
    <item>
      <title>SpringMVC</title>
      <link>https://sherry-long.github.io/post/springmvc/</link>
      <pubDate>Tue, 11 Oct 2022 11:02:42 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/springmvc/</guid>
      <description>​	一、SpringMVC特点
​	二、创建SpringMVC工程
​	三、@RequestMapping注解
​	四、SpringMVC获取请求参数
​	五、域对象共享数据
​	六、SpringMVC的视图
​	七、RESTful
​	八、HttpMessageConverter
​	九、文件上传和下载
​	十、拦截器
​	十一、异常处理器
​	十二、注解配置SpringMVC
​	十三、SpringMVC执行流程
SpringMVC是Spring的一个后续产品，是Spring的一个子项目
SpringMVC是Spring为表述层开发提供的一套完备的解决方案。(三层架构分别为表述层(表示层)、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet)
#
一、SpringMVC的特点 1）Spring 家族原生产品，与IoC容器等基础设施无缝对接 2）基于原生的Servlet，通过功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 3）表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 4）代码清新简洁，大幅度提升开发效率 5）内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 6）性能卓著，尤其适合现代大型、超大型互联网项目要求   #
二、创建SpringMVC工程 创建maven工程 1.pom.xml中引入依赖，打包方式：war &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;org.sherry&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo1&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;11&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;11&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!-- SpringMVC --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.3.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>Java8新特性</title>
      <link>https://sherry-long.github.io/post/java8news/</link>
      <pubDate>Sat, 08 Oct 2022 19:36:49 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java8news/</guid>
      <description>Lambda表达式 Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。 使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。
  作用：简化匿名内部类的代码写法
  本质：作为接口(内部只能有一个抽象方法 a.k.a 函数式接口)的实例
  public class lambda { @Test public void test(){ //常规写法  Comparator&amp;lt;Integer&amp;gt; com = new Comparator&amp;lt;Integer&amp;gt;() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1, o2); } }; int compare1 = com.compare(12, 21); System.out.println(compare1); //Lambda表达式写法  Comparator&amp;lt;Integer&amp;gt; com1 = (o1, o2) -&amp;gt; Integer.compare(o1, o2); int compare2 = com1.compare(12, 21); System.out.println(compare2); /* exp : (o1, o2) -&amp;gt; Integer.</description>
    </item>
    
    <item>
      <title>Java反射</title>
      <link>https://sherry-long.github.io/post/javareflection/</link>
      <pubDate>Sun, 02 Oct 2022 15:57:12 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javareflection/</guid>
      <description>反射机制概述 反射被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法  加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。  动态语言 在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。
 在运行时代码可以根据某些条件改变自身结构 *  如Object-C、C#、JavaScript、PHP、Python、Erlang
静态语言 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++
 Java不是动态语言，但是Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性   Java反射机制提供的功能
&amp;gt;在运行时判断任意一个对象所属的类 &amp;gt;在运行时构造任意一个类的对象 &amp;gt;在运行时判断任意一个类所具有的成员变量和方法 &amp;gt;在运行时获取泛型信息 &amp;gt;在运行时调用任意一个对象的成员变量和方法 &amp;gt;在运行时处理注解 &amp;gt;生成动态代理  @Test public void test() throws Exception { //通过反射方式获取类，构造器，并创建对象  Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;#34;Person&amp;#34;); Object o = personClass.getDeclaredConstructor(String.class, int.class, boolean.class).newInstance(&amp;#34;Tom&amp;#34;, 24, true); Person p = (Person) o; //通过反射调用方法  System.out.println(personClass.getDeclaredMethod(&amp;#34;toString&amp;#34;).invoke(p)); // Person{name=&amp;#39;Tom&amp;#39;, age=24, isMale=true, privateMember=&amp;#39;can not access&amp;#39;}  //通过反射修改属性值  personClass.getField(&amp;#34;name&amp;#34;).set(p, &amp;#34;Jerry&amp;#34;); System.out.println(personClass.getDeclaredMethod(&amp;#34;toString&amp;#34;).invoke(p)); // Person{name=&amp;#39;Jerry&amp;#39;, age=24, isMale=true, privateMember=&amp;#39;can not access&amp;#39;}  //通过反射可以调用类的私有结构  Field privateMember = personClass.</description>
    </item>
    
    <item>
      <title>Java网络编程-UDP、URL</title>
      <link>https://sherry-long.github.io/post/javanetprogram1/</link>
      <pubDate>Fri, 30 Sep 2022 16:08:51 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javanetprogram1/</guid>
      <description>UDP网络编程 UDP协议 数据传输 public class UDPTest { //发送端  @Test public void send() throws IOException { //TCP使用Socket，UDP使用DatagramSocket  DatagramSocket ds = new DatagramSocket(); byte[] data = &amp;#34;this is a sentence&amp;#34;.getBytes(); //将要传输的数据封装在DatagramPacket中  DatagramPacket packet = new DatagramPacket(data, 0, data.length, InetAddress.getLocalHost(), 8989); //使用DatagramSocket对象传输packet  ds.send(packet); ds.close(); } //接收端  @Test public void receive() throws IOException { //指定DatagramSocket端口  DatagramSocket ds = new DatagramSocket(8989); byte[] data = new byte[100]; //使用DatagramPacket对象接收数据  DatagramPacket packet = new DatagramPacket(data, 0, data.</description>
    </item>
    
    <item>
      <title>Java网络编程-TCP</title>
      <link>https://sherry-long.github.io/post/javanetprogram/</link>
      <pubDate>Tue, 27 Sep 2022 11:28:54 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javanetprogram/</guid>
      <description>概述 Java从语言级上提供了对网络应用程序的支持。Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在Java的本机安装系统里，由JVM进行控制。 并且Java实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。
 InetAddress类 代表IP地址，此类用于获取IP地址，可通过域名解析方式获取
端口号 + IP地址 &amp;mdash;包装&amp;mdash;&amp;gt; 网络套接字(Socket) 端口号标识正在计算机上运行的程序(进程)
  不同的进程有不同的端口号
  被规定为一个16位的整数0~65535
  端口分类：
  &amp;gt;公认端口：0~1023。被预先定义的服务通信占用(HTTP:80, FTP:21, Telnet:23等) &amp;gt;注册端口：1024~49151。分配给用户进程或应用程序(Tomcat:8080, MySQL:3306, Oracle:1521等) &amp;gt;动态/私有端口：49152~65535 端口号与IP地址的组合得出一个网络套接字：Socket  TCP网络编程 /** * @author sherry-long * @create 2022-09-29 上午 10:39 */ public class TCPTest { @Test public void client() {//客户端  Socket socket = null; OutputStream os = null; try { InetAddress inet = InetAddress.getByName(&amp;#34;127.0.0.1&amp;#34;);//本机IP  socket = new Socket(inet, 8880);//使用IP + 端口号创建套接字  os = socket.</description>
    </item>
    
    <item>
      <title>JavaIO流 2</title>
      <link>https://sherry-long.github.io/post/javaio1/</link>
      <pubDate>Fri, 23 Sep 2022 09:14:51 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaio1/</guid>
      <description>转换流(处理流的一种，属于字符流) (utf-8.txt) ==字节流==&amp;gt; InputStreamReader(utf-8) ==字符流==&amp;gt; [程序]
[程序] ==字符流==&amp;gt; OutputStreamWriter(gbk) ==字节流==&amp;gt; (gbk.txt)
 1.转换流： InputStreamReader：将一个字节的输入流转换为字符输入流 OutputStreamWriter：将一个字符输出流转换为字节输出流 2.作用：提供字节流与字符流之间的转换 3.解码：字节、字节数组 ---&amp;gt; 字符数组、字符串 编码：字符数组、字符串 ---&amp;gt; 字节、字节数组 4.字符集 略  了解  标准输入输出流 System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream System.out的类型是PrintStream，是OutputStream的子类FilterOutputStream的子类 重定向：通过System类的setIn，setOut方法对默认设备进行改变 public static void setIn(InputStream in) public static void setOut(PrintStream out)  使用标准输入流自定义接受键盘输入  public static void main(String[] args) { BufferedReader br = null; try { InputStreamReader isr = new InputStreamReader(System.in); br = new BufferedReader(isr); String str = br.</description>
    </item>
    
    <item>
      <title>JavaIO流 1</title>
      <link>https://sherry-long.github.io/post/javaio/</link>
      <pubDate>Mon, 19 Sep 2022 11:02:18 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaio/</guid>
      <description>File类的使用 @Test public void test() { //绝对路径打开文件  File file1 = new File(&amp;#34;c:&amp;#34; + File.separator + &amp;#34;Users&amp;#34; + File.separator + &amp;#34;10706&amp;#34; + File.separator + &amp;#34;IdeaProjects&amp;#34; + File.separator + &amp;#34;IDEApro4&amp;#34; + File.separator + &amp;#34;src&amp;#34; + File.separator + &amp;#34;JavaIO&amp;#34; + File.separator + &amp;#34;others.txt&amp;#34;); //相对路径打开文件，相对于当前工程  File file2 = new File(&amp;#34;article.txt&amp;#34;); /** * article.txt: this is an article * others.txt: this is a sentence */ System.out.println(file1.isFile());//t  System.out.println(file1.canRead());//t  System.out.println(file1.canWrite());//t  System.out.println(file1.canExecute());//t  System.</description>
    </item>
    
    <item>
      <title>Java泛型</title>
      <link>https://sherry-long.github.io/post/javat/</link>
      <pubDate>Sat, 17 Sep 2022 08:32:14 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javat/</guid>
      <description>为什么要有泛型 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。
这个类型参数将在使用时(例如，继承或实现这个接口，用这个类型声明变量、创建对象时)确定(即传入实际的类型参数，也称为类型实参)
 在集合中使用泛型   集合接口或集合类在jdk5.0时都修改为带泛型的结构
  在实例化集合类时，可以指明具体的泛型类型
  指明完以后，在集合类或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置，都指定为实例化的泛型类型
  比如：add(E e) &amp;mdash;&amp;gt; 实例化以后：add(Integer e)
  注意点：泛型的类型必须是一个类，不能是基本数据类型，要使用包装类
  如果实例化时没有指明泛型的类型，默认类型为 Object 类型
   自定义范型结构 泛型类、泛型接口 public class Order&amp;lt;T&amp;gt; { String orderName; int orderId; //把参数T当成一个类型来用(但T其实并不是一个类，它只是一个参数)  T orderT; public Order(){}; public Order(String orderName, int orderId, T orderT){ this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; } public T getOrderT() { return orderT; } public void setOrderT(T orderT) { this.</description>
    </item>
    
    <item>
      <title>Java集合2</title>
      <link>https://sherry-long.github.io/post/javacollection2/</link>
      <pubDate>Wed, 14 Sep 2022 15:37:29 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javacollection2/</guid>
      <description>Map Map接口：双列数据，保存具有映射关系&amp;quot;key-value对&amp;quot;的集合 &amp;gt;HashMap：Map的主要实现类； 线程不安全，效率高； 可以存储null的key和value，健壮性高 &amp;gt;LinkedHashMap：在HashMap基础之上加了一对指针，可以按照添加的顺序遍历 对于频繁的遍历操作，此类效率高于HashMap &amp;gt;TreeMap：保证按照添加的key-value对进行排序，实现排序遍历 (按key进行排序) &amp;gt;HashTable：Map的古老实现类； 线程安全，效率低； 不能存储null的key和value(任何一个是null都不行)健壮性差 &amp;gt;Properties：常用来处理配置文件，key和value都是String类型 Map的 key-value对 的理解(以HashMap为例) key：无序不可重复，使用Set存储所有的key &amp;mdash;&amp;gt; key所在的类要重写equals()方法和hashCode()方法
value：无序可重复，使用Collection存储所有的value &amp;mdash;&amp;gt; value所在的类要重写equals()方法
一个键值对：key-value构成一个entry对象
entry：无序不可重复，使用Set存储所有的entry
Map中的常用方法(HashMap为例) @Test public void test1(){ Map map = new HashMap(); //put  //添加  map.put(&amp;#34;AA&amp;#34;, 123); map.put(&amp;#34;BB&amp;#34;, 234); map.put(45, 123); map.put(&amp;#34;CC&amp;#34;, 123); //同key，修改  map.put(&amp;#34;AA&amp;#34;, 456); System.out.println(map);//{AA=456, BB=234, CC=123, 45=123}  //putAll  Map map1 = new HashMap(); map1.put(&amp;#34;CC&amp;#34;, 456); map1.put(&amp;#34;DD&amp;#34;, 123); map.putAll(map1); System.out.println(map);//{AA=456, BB=234, CC=456, DD=123, 45=123}  //remove 返回value  Object value = map.</description>
    </item>
    
    <item>
      <title>Java集合1</title>
      <link>https://sherry-long.github.io/post/javacollection/</link>
      <pubDate>Thu, 08 Sep 2022 12:35:51 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javacollection/</guid>
      <description>概述 使用Array存储对象方面具有一些弊端，而Java集合就像一种容器，可以动态的把多个对象的引用放入容器中
 数组在内存存储方面的特点：  数组初始化以后，长度就确定了 数组声明的类型，就决定了进行元素初始化时的类型  数组在存储数据方面的弊端  数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高 无法直接获取存储元素的个数 数组存储的数据是有序的、可以重复的，存储数据特点单一 Java集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组 Java集合可分为 Collection 和 Map 两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合 &amp;gt;List：元素有序，可重复的集合(动态数组) ArrayList, LinkedList, Vector &amp;gt;Set：元素无序，不可重复的集合 HashSet, LinkedHashSet, TreeSet Map接口：双列数据，保存具有映射关系&amp;quot;key-value对&amp;quot;的集合 &amp;gt;HashMap LinkedHashMap &amp;gt;TreeMap &amp;gt;HashTable &amp;gt;Properties   Collection  Collection接口中的常用方法 @Test public void test1(){ Collection coll = new ArrayList(); //add(obj) 将元素obj添加到集合中  coll.add(&amp;#34;this is a sentence&amp;#34;); coll.add(1); coll.add(1.5); coll.add(1234L); System.out.println(coll.size()); //addAll(Collection coll) 将集合coll中的所有元素添加到coll1中  Collection coll1 = new ArrayList(); coll1.addAll(coll); coll1.</description>
    </item>
    
    <item>
      <title>Java枚举类与注解</title>
      <link>https://sherry-long.github.io/post/javaenum/</link>
      <pubDate>Tue, 06 Sep 2022 09:18:27 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaenum/</guid>
      <description>枚举类 什么是枚举类 类的对象只有确定的有限个 星期：周一二三 性别：男女 季节：春夏秋冬 支付方式：扫码现金 就职状态：Busy，Free，Vacation，Dismissed 订单状态：。。。 线程状态：创建，就绪，运行，阻塞，死亡
当需要定义一组常量时，建议使用枚举类  如何自定义枚举类(JDK5之前) class Weekday{ //声明对象属性， private final 修饰  private final String DayName; private final int DayNum; //私有化构造方法  private Weekday(String dayName, int dayNum){ this.DayNum = dayNum; this.DayName = dayName; } //创建多个对象，public static final 修饰  public static final Weekday Monday = new Weekday(&amp;#34;Monday&amp;#34;, 1); public static final Weekday Tuesday = new Weekday(&amp;#34;Tuesday&amp;#34;, 2); public static final Weekday Wednesday = new Weekday(&amp;#34;Wednesday&amp;#34;, 3); public static final Weekday Thursday = new Weekday(&amp;#34;Thursday&amp;#34;, 4); public static final Weekday Friday = new Weekday(&amp;#34;Friday&amp;#34;, 5); public static final Weekday Saturday = new Weekday(&amp;#34;Saturday&amp;#34;, 6); public static final Weekday Sunday = new Weekday(&amp;#34;Sunday&amp;#34;, 7); //Getters、toString方法  public String getDayName() { return DayName; } public int getDayNum() { return DayNum; } @Override public String toString() { return &amp;#34;Weekday{&amp;#34; + &amp;#34;DayName=&amp;#39;&amp;#34; + DayName + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, DayNum=&amp;#34; + DayNum + &amp;#39;}&amp;#39;; } }  如何使用关键字enum定义枚举类(JDK5新特性) enum Weekday{//enum类继承于java.</description>
    </item>
    
    <item>
      <title>Java常用类2</title>
      <link>https://sherry-long.github.io/post/javacommonclass1/</link>
      <pubDate>Thu, 01 Sep 2022 17:26:46 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javacommonclass1/</guid>
      <description>Java比较器 Java中的对象，正常情况下，只能进行比较 == 或 !=，不能使用 &amp;gt; 或 &amp;lt;
但有时，我们需要对多个对象进行排序，需要比较对象的大小
通过使用 Comparable 或 Comparator 接口来实现
 Comparable接口(自然排序) 重写compareTo(obj)方法：
 如果当前对象this大于形参对象obj，返回正整数 如果当前对象this小于形参对象obj，返回负整数 如果当前对象this等于形参对象obj，返回零  class Goods implements Comparable{ private String name; private double price; @Override public String toString() { return &amp;#34;Goods{&amp;#34; + &amp;#34;name=&amp;#39;&amp;#34; + name + &amp;#39;\&amp;#39;&amp;#39; + &amp;#34;, price=&amp;#34; + price + &amp;#39;}&amp;#39;; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.</description>
    </item>
    
    <item>
      <title>Java常用类1</title>
      <link>https://sherry-long.github.io/post/javacommonclass/</link>
      <pubDate>Thu, 01 Sep 2022 17:11:14 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javacommonclass/</guid>
      <description>String相关  String String是一个final类，无法被继承，支持序列化
String不可变字符序列，String内部并没有修改内容相应方法，每次修改String的方法其实质是创建一个新对象并将原引用指向它
String str1 = &amp;#34;abc&amp;#34;; // 字面量，区别于new String str2 = &amp;#34;abc&amp;#34;; //此时str1和str2指向的是常量池中的同一地址 //字符串常量池中不会存储两个相同的字符串 str1 == str2.sout //结果为true   String不可变性体现：
 1. 当对字符串重新赋值时，需要重新指定内存区域赋值 2. 当对现有字符串进行连接操作时( + )，也需要重新制定内存区域进行赋值 3. 当调用String的 replace(oldChar, newChar) 方法修改指定字符或字符串时，也需要重新制定内存区域进行赋值    String对象的创建 String str = &amp;#34;hello&amp;#34;; String s1 = new String();// this.value = new char[0];  String s2 = new String(String original);// this.value = original.value;  String s3 = new String(char[] a);// this.</description>
    </item>
    
    <item>
      <title>Java线程1</title>
      <link>https://sherry-long.github.io/post/javathread/</link>
      <pubDate>Mon, 29 Aug 2022 09:22:08 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javathread/</guid>
      <description>进程与线程 进程是资源分配的单位，线程是调度和执行的单位 线程是进程的一个执行单元，一个线程就是进程中一个单一的控制流
进程是线程的容器，一个进程至少有一个线程，一个进程中也可以有多个线程
并发与并行 并行是指两个或者多个事件在同一时刻发生，而并发是指两个或多个事件在同一时间间隔发生。
并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
使用多线程的优点   1.提高应用程序的响应速度。对图形化界面更有意义，可增强用户体验
  2.提高计算机系统CPU的利用率
  3.改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改
  何时需要多线程   程序需要同时执行两个或多个任务
  程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等
  需要一些后台运行的程序时
   线程的创建和使用-4种创建方式 可以通过两种方法实现线程类： 1）继承Thread类 ； 2 ）实现Runnable接口
 1） 1. 继承Thread类 2. 重写run方法，run方法内部就是你的线程要做的事情 3. 创建子线程对象 4. 启动线程 thread.start() 调用start()方法来启动线程，启动线程的实质就是请求JVM运行相应线程，这个线程具体在什么时候运行 由线程调度器决定 Scheduler 2） 当线程类已经有父类了，就不能继承Thread类了， 1. 实现Runnable接口，重写run方法，run方法内部就是你的线程要做的事情 2. 创建Runnable接口实现类对象 Myrunnable runnable = new Myrunnable(); 3. 创建线程对象 Thread thread = new Thread(runnable); 4.</description>
    </item>
    
    <item>
      <title>杂项</title>
      <link>https://sherry-long.github.io/post/javaothers/</link>
      <pubDate>Thu, 25 Aug 2022 11:33:59 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javaothers/</guid>
      <description>其他  String s = new String(&amp;quot;asdf&amp;quot;); 声明一个对象引用s，new：给我一个新对象 Java对象创建在堆上，对象引用在堆栈上 对象为什么不在堆上：创建程序时，Java系统必须知道存储在堆栈内的所有项的确切生命周期，以便上下移动堆栈指针（分配新内存以及回收内存） 在堆中存储时，编译器不需要知道存储的数据在堆中存活多久，更有灵活性，但是在堆中进行内存分配和清理比堆栈花时间更多 对于基本类型，将他们存储在堆栈上不是很高效，new时，创建一个并非是引用的“自动“变量，这个变量直接存储值，并存储在堆栈上，更加高效。 （基本类型，变量直接储存值） 当创建一个数组对象时，对象会被自动初始化 Array.copyOfRange(int[] source, int from, int to):返回一个数组，复制 source 数组从 from 位到 to 位的内容，不包括to位，长度为 to - from 。 在Java中，负数自动以补码形式保存， &amp;gt;&amp;gt; 为带符号右移，正数高位补 0 ，负数高位补 1 ，&amp;gt;&amp;gt;&amp;gt; 为无符号右移，正数负数高位都补 0 。 比较两个浮点数，不能直接使用 == 方法一：指定一个误差范围，两个浮点数的差值在此范围之内，则认为两数相等  float diff = 1e-6f; if (Math.abs(float1 - float2) &amp;lt; diff) return true;  方法二：使用BigDecimal来定义值，再进行浮点数的操作运算  BigDecimal a = new BigDecimal(&amp;#34;1.0&amp;#34;); BigDecimal b = new BigDecimal(&amp;#34;0.9&amp;#34;); BigDecimal c = new BigDecimal(&amp;#34;0.</description>
    </item>
    
    <item>
      <title>Java关键字</title>
      <link>https://sherry-long.github.io/post/javakeywords/</link>
      <pubDate>Thu, 25 Aug 2022 11:33:41 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javakeywords/</guid>
      <description>关键字 this关键字 创建一个对象时分以下四部： 1.分配对象空间，将对象成员变量初始化为0或空 2.执行显示值的属性初始化 3.执行构造方法 this(**) 4.返回对象的地址给相关变量
this 指的是**“创建好的对象的地址”**，在调用构造方法时，对象已被创建，在构造方法中使用this，代表“当前对象”
this 用法 1. this.name = name; 避免程序二义 2. 使用this关键字调用重载的构造方法，避免初始化代码重复。 只能在构造方法中使用，只能引用一个，必须位于构造方法的第一句 （在构造器中，如果为this添加了参数列表，那么就有不同的含义。这将产生对符合此参数列表的某个构造器的明确调用） 3. this 不能用于static方法中（因为静态方法不依赖对象来进行访问，没有对象就谈不上this） 4. this 将当前对象本身作为参数传递给其他方法 5. return this; this 将当前对象作为参数返回，这样可以对一个对象进行多次操作
  static关键字 当声明一个域或方法是static时，意味着这个域或方法不与包含他的那个类的任何对象关联在一起，与类相关联
方便在没有创建对象的情况下来进行调用（方法/变量） 1. static方法： 静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的 不需要对象便可通过类名进行调用（但是也可以通过对象进行调用）
 2. static变量： 静态变量被所有对象共享，在内存中只有一个副本 随着类的加载而加载，早于对象被创建 3. static代码块： 优化程序性能（重复代码块） private static Date startDate,endDate; static{ startDate = Date.valueOf(&amp;quot;1946&amp;quot;); endDate = Date.valueOf(&amp;quot;1964&amp;quot;); } static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的 在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 构造器是static方法，它不需要对象来调用  static不会改变方法和变量的访问权限
静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）
开发中,如何确定一个属性是否要声明为static?   1.</description>
    </item>
    
    <item>
      <title>旋转打印 1 ~ n方(Java)</title>
      <link>https://sherry-long.github.io/post/generatematrix/</link>
      <pubDate>Tue, 23 Aug 2022 15:05:36 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/generatematrix/</guid>
      <description>输入 3  输出 int[][]res = 1 2 3 8 9 4 7 6 5  思路 确定循环不变量，确保填充数据时不会重复填充、缺省填充
将每一圈的数据填充过程分为四条边，每条边填充第一个至倒数第二个数据，即[0,n),左闭右开
坚持这个原则，严格控制每一条边的填充长度，即可。
Java实现 public static int[][] generateMatrix(int n) { int[][] res = new int[n][n]; int startx = 0, starty = 0, //起始坐标 	loop = n / 2, mid = n / 2, //循环次数，以及中间位置 	offset = 1, count = 1, //每条边的偏移量，以及计数器 	i, j; //游标i、j  while (loop-- != 0) { i = startx; j = starty; for (; j &amp;lt; starty + n - offset; j++)//最上面一条边 	res[i][j] = count++; for (; i &amp;lt; startx + n - offset; i++)//最右方一条边 	res[i][j] = count++; for (; j &amp;gt; starty; j--)//最下面一条边 	res[i][j] = count++; for (; i &amp;gt; startx; i--)//最左方一条边 	res[i][j] = count++; startx++; starty++; offset += 2;//一圈填完，圈收缩，起始坐标改变，偏移量改变  } if (n % 2 == 1) res[mid][mid] = count;//所有圈填完，查看正中央是否有独立空位 	return res; } </description>
    </item>
    
    <item>
      <title>设计模式(Java)</title>
      <link>https://sherry-long.github.io/post/designpatterns/</link>
      <pubDate>Tue, 23 Aug 2022 11:52:56 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/designpatterns/</guid>
      <description>设计模式
 创建型模式  工厂模式 抽象工厂模式 单例模式 建造者模式 原型模式   结构型模式  适配器模式 桥接模式 过滤器模式 组合模式 装饰器模式 外观模式 享元模式 代理模式   行为型模式  责任链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 空对象模式 策略模式 模板模式 访问者模式    单例模式 Java中，可用static来实现单例模式
饿汉式 (优点：天然线程安全 ； 缺点：对象存续时间过长，当短时间内不需要此对象时会浪费空间)
class New1 { private New1() { //构造方法要私有化，不允许外部直接调用构造方法 	} private static New1 new1 = new New1(); public static New1 getInstance() { return new1;//不管用不用直接创建，饥不择食 	} } 懒汉式 (优点：延迟对象的创建，不会浪费空间 ； 缺点：需要手动加锁实现线程安全)</description>
    </item>
    
    <item>
      <title>JavaSE</title>
      <link>https://sherry-long.github.io/post/javase/</link>
      <pubDate>Mon, 22 Aug 2022 11:28:43 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/javase/</guid>
      <description>Java基础 序列化和反序列化 序列化：将对象写入到IO流中 反序列化：从IO流中恢复对象 序列化机制允许将实现序列化的Java对象转换为字节序列，这些字节序列可以保存在磁盘上， 或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序运行而独立存在
所有可在网络上传输的对象都必须是可序列化的，所有需要保存到磁盘上的对象都必须是可序列化的
反序列化不会调用构造方法，对象是由JVM自己生成的
所有保存到磁盘上的对象都有一个序列化编码 在程序试图序列化一个对象时，会先检查此对象是否已经被序列化过，如果已经序列化直接输出编号
对一个已经序列化的对象进行修改后，再次序列化则不会保存 transient（暂时）变量和static（静态）变量在序列化时会忽视
关于arraylist底层自定义序列化方法： arraylist底层采用数组实现，采用算法实现动态数组，数组通常不会被填满，直接调用序列化会序列化很多null对象， 所以将elementData定义为transient防止直接序列化，重写序列化反序列化方法，循环遍历将元素序列化进流中
  可变参数 类型 + &amp;hellip; + 形参名 定义时： f(Object&amp;hellip; trailing); 调用时： f(&amp;ldquo;one&amp;rdquo;); f(&amp;ldquo;one&amp;rdquo;, &amp;ldquo;two&amp;rdquo;); f(1,2,3); f(&amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;); f(); 都可以,会自动转型成object
  复用类 组合： 继承： 使用通用类构造一个特例。。。。抽象特征提取，减少重复代码，增加代码可复用性
代理： 重载(overload)：  在同一个类中，同名不同参的函数定义是重载 是否为重载关系，只看方法名(须相同)与参数列表(须不同，类型、数量、顺序等)，不看返回值类型  覆写or重写(override/overwrite)：  子类复写(覆盖)父类中的同名同参方法，子类重写的方法的权限修饰符 不小于父类被重写方法的权限修饰符。 子类不能重写父类中private修饰的方法。 父类被重写的方法的返回值类型是void，则子类重写方法的返回值类型也是void。 父类被重写方法的返回值类型是A，则子类重写方法的返回值类型只能是A或A的子类。 父类被重写方法的返回值类型是基本数据类型，则子类重写方法的返回值类型必须是相同的基本数据类型。 子类重写方法抛出的异常不大于父类被重写的方法抛出的异常。  对于重载 编译器在编译时期就能知道调用的具体方法是哪个，各个同名方法的地址在编译期就决定了 ** 早绑定(静态绑定) **
对于重写 只有在真正执行时，编译器才知道具体调用的是哪个方法 ** 晚绑定(动态绑定) **
  子类对象实例化   从结果上看（继承性）</description>
    </item>
    
    <item>
      <title>BST的后序遍历序列 Java</title>
      <link>https://sherry-long.github.io/post/java13/</link>
      <pubDate>Mon, 08 Mar 2021 12:58:48 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java13/</guid>
      <description>题目：
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。
示例：
 输入：[4,8,6,12,16,14,10] 输出：true  思路：
树形结构题目一般都采用递归来解决
我们知道BST的后序遍历序列中，根节点是最后遍历到的，所以我们将末尾元素保存，这就是树的根节点，然后根据BST的性质，跟节点的左子树都小于它，右子树都大于它来进行递归判断
在此题目中要时刻注意边界问题的判断，比如在首次进行判断时，我们要注意序列的长度，此时序列长度为 1 或 2 时是不需要进行判断的，它先天满足BST后序遍历的条件，如果是空序列则也不需要进行判断直接返回false
同理，在递归的过程中遇到长度小于 3 的序列可以直接输出 true 不需要判断
java实现：
import java.util.*; public class Solution { public boolean VerifySquenceOfBST(int [] sequence) { if (sequence.length &amp;lt; 3 &amp;amp;&amp;amp; sequence.length != 0) return true; if (sequence.length == 0) return false; // 首次执行判断，根据长度选择执行分支  return function(sequence); } public boolean function(int [] sequence ){ if(sequence.length &amp;lt; 3) return true; // 此为结束条件，长度为 1 ，2 的序列先天满足BST后序遍历性质  int pivot = sequence[sequence.</description>
    </item>
    
    <item>
      <title>从上到下层次遍历二叉树 Java</title>
      <link>https://sherry-long.github.io/post/java12/</link>
      <pubDate>Sun, 07 Mar 2021 19:48:35 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java12/</guid>
      <description>题目：
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
示例：
 输入：{5,4,#,3,#,2,#,1} 输出：[5,4,3,2,1]  思路：
层次遍历二叉树可以借助队列来实现，先将根节点入队，然后将队首元素(此时只有根节点一个)出队，将它的左右孩子按序入队，循环此操作直到队列为空
Java中的Queue是接口，不能直接创建实例，可以借助LinkedList来创建。我们创建一个TreeNode类型的queue，来保存遍历顺序，每次队首元素出队时，将它的值保存在res中
注意空树的处理
java实现：
import java.util.*; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList&amp;lt;Integer&amp;gt; PrintFromTopToBottom(TreeNode root) { Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;TreeNode&amp;gt;(); ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;Integer&amp;gt;(); if(root == null) return res; queue.add(root); // 根节点入队  while(!queue.isEmpty()){ if(queue.</description>
    </item>
    
    <item>
      <title>树的子结构 Java</title>
      <link>https://sherry-long.github.io/post/java11/</link>
      <pubDate>Sun, 28 Feb 2021 10:51:26 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java11/</guid>
      <description>题目：
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
示例：
 输入：{8,8,#,9,#,2,#,5},{8,9,#,2} 返回：true  思路：
树结构的问题一般都考虑使用递归方法
子函数 isSubTree ，判断 root2 是否为 root1 的子树，依次遍历两颗树的节点，如果 root2 遍历结束则是子树，如果遍历未完成(root1 遍历结束或中途有节点不相等)，false
HasSubtree 方法使用递归思路结合子函数 isSubTree 来进行判断
java实现：
/** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { boolean isSubTree(TreeNode root1, TreeNode root2){ if(root2 == null) return true; // root2 遍历结束返回真  if(root1 == null) return false; // root1 遍历结束返回假  if(root1.</description>
    </item>
    
    <item>
      <title>链表中倒数第k个节点 Java</title>
      <link>https://sherry-long.github.io/post/java10/</link>
      <pubDate>Wed, 24 Feb 2021 09:45:21 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java10/</guid>
      <description>题目：
输入一个链表，输出该链表中倒数第k个结点。
示例：
 输入：1,{1,2,3,4,5} 输出：{5}  思路：
定义两个游标cur1 cur2，两个都指向头结点，然后将 cur2 先向后移动 k - 1 个位置，再同时移动两个游标直到 cur2 到达链尾，返回cur1即可。
注意空链表以及 k 大于链表长度时的处理操作
java实现：
/* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode FindKthToTail(ListNode head,int k) { if(head == null || k == 0){ //如果空链或 k = 0 返回 null  return null; } ListNode cur1 = head, cur2 = head; for(int i = 0; i &amp;lt; k - 1; ++i){ if(cur2.</description>
    </item>
    
    <item>
      <title>调整数组顺序使奇数位于偶数前面 Java</title>
      <link>https://sherry-long.github.io/post/java9/</link>
      <pubDate>Tue, 16 Feb 2021 19:35:44 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java9/</guid>
      <description>题目：
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
示例：
 输入：[1, 2, 3, 4, 5, 6, 7] 输出：[1, 3, 5, 7, 2, 4, 6]  思路：
两种思路
 第一种：结合选择排序的思想，定义两个游标，一个 i 用来从头查找奇数元素，一个 count 用来表示已经排好的奇数个数， 每次将奇数元素调整到 count 位置，再将 count + 1 第二种：借助队列，空间换时间  java实现：
import java.util.*; public class Solution { public void reOrderArray(int [] array) { // int count = 0; //count表示已经排好位置的奇数个数 // for(int i = 0; i &amp;lt; array.length; ++i) // { // if((array[i] + 1) % 2 == 0) // { // int j = i; // while(j &amp;gt; count) // { // int temp = array[j]; // array[j] = array[j - 1]; // array[j - 1] = temp; // j--; // } //遍历数组，将每个奇数前挪 // ++count; //挪完后计数器+1 // } // }  Queue&amp;lt;Integer&amp;gt; Odd = new LinkedList&amp;lt;Integer&amp;gt;(); Queue&amp;lt;Integer&amp;gt; Even = new LinkedList&amp;lt;Integer&amp;gt;(); for(int i = 0; i &amp;lt; array.</description>
    </item>
    
    <item>
      <title>二进制中 1 的个数 Java</title>
      <link>https://sherry-long.github.io/post/java8/</link>
      <pubDate>Tue, 16 Feb 2021 11:48:07 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java8/</guid>
      <description>题目：
输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。
示例：
 输入：10 返回：2  思路：
主要过程：通过与 1 进行 &amp;amp; 操作可以获得最低位的数，0 或 1，根据此进行统计
需要注意负数的情况，在Java中负数是以补码形式存储的，有两种思路：
 1.将负数数值部分取出，使用 &amp;gt;&amp;gt; 进行右移，结束后计数器要再加一，因为少了符号位的 1 2.正数负数统一操作，使用 &amp;gt;&amp;gt;&amp;gt; 无符号进行右移，高位补0  Java实现：
第一种实现：
public class Solution { public int NumberOf1(int n) { int count = 0; //计数器  if(n &amp;lt; 0) { n = n &amp;amp; 0x7FFFFFFF; ++count; //将负数的补码的数值部分取出，并将符号位的 1 手动加入计数器中  } //此步骤是为了防止下方循环进入死循环  while(n != 0) { count += n &amp;amp; 1; //每次拿 n 的最低位与 1 进行与操作，并计入计数器  n = n &amp;gt;&amp;gt; 1; //对 n 进行带符号右移，此时负数已由上面操作转为正数，进行右移时不会再高位补 1，也就不会陷入死循环  } return count; } } 第二种实现：</description>
    </item>
    
    <item>
      <title>斐波那契数列 Java</title>
      <link>https://sherry-long.github.io/post/java7/</link>
      <pubDate>Fri, 12 Feb 2021 10:42:17 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java7/</guid>
      <description>题目：
java实现斐波那契数列
思路：
动态规划思路，使用备忘录机制，定义一个静态数组result[]，将计算过的结果保存在result中，每次要进行计算之前，检查相应位置是否已经计算过，如果计算过直接返回该值。
Java实现：
public class Solution { static int result[] = new int[40]; // 静态result作备忘录  static{ result[0] = 0; result[1] = 1; for(int i = 2; i &amp;lt; 40; i++) result[i] = -1; // 静态代码块，对result中的值进行赋初始值  } public int Fibonacci(int n) { int temp = -1; if(result[n] == temp) // 如果相应位置未进行计算  { temp = Fibonacci(n - 1) + Fibonacci(n - 2); result[n] = temp; // 进行计算并且将结果储存  } return result[n]; // 返回result[n]  } } 题目来源：剑指offer</description>
    </item>
    
    <item>
      <title>寻找旋转数组最小值 Java</title>
      <link>https://sherry-long.github.io/post/java6/</link>
      <pubDate>Thu, 11 Feb 2021 20:12:34 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java6/</guid>
      <description>题目：
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
示例：
 输入：[3,4,5,1,2] 输出：1  思路：
二分思想。取中间元素mid，与末尾元素high进行比较，可能出现的情况如下：
 1.mid &amp;gt; high 说明最小元素在右半边数组中 2.mid &amp;lt; high 说明最小元素在左半边数组中 3.mid = high 此情况下数组应类似 [1,1,0,1]，此时缩短high进行试探，直到mid != high  Java实现：
import java.util.*; public class Solution { public int minNumberInRotateArray(int [] array) { int low = 0, high = array.length - 1; if(array.length == 0) return 0; while(low &amp;lt; high) { int mid = low + (high - low) / 2; if(array[mid] &amp;gt; array[high]) low = mid + 1; else if(array[mid] == array[high]) high--; else high = mid; } return array[low]; }} 题目来源：剑指offer</description>
    </item>
    
    <item>
      <title>用两个栈实现队列 Java</title>
      <link>https://sherry-long.github.io/post/java5/</link>
      <pubDate>Thu, 11 Feb 2021 18:13:51 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java5/</guid>
      <description>题目：
用两个栈来实现一个队列，完成队列的Push和Pop操作。
队列中的元素为int类型。
思路：
我的想法是，push操作使用stack1进行，pop操作用stack2进行
pop操作时，如果stack2内容为空，就把stack1的内容pop到stack2中，然后正常进行pop操作
Java实现：
import java.util.Stack; public class Solution { Stack&amp;lt;Integer&amp;gt; stack1 = new Stack&amp;lt;Integer&amp;gt;(); Stack&amp;lt;Integer&amp;gt; stack2 = new Stack&amp;lt;Integer&amp;gt;(); public void push(int node) { stack1.push(node); } public int pop() { if(stack2.empty()){ while(!stack1.empty()){ stack2.push(stack1.pop()); } } return stack2.pop(); } } 题目来源：剑指offer</description>
    </item>
    
    <item>
      <title>反向打印链表 Java</title>
      <link>https://sherry-long.github.io/post/java4/</link>
      <pubDate>Thu, 11 Feb 2021 17:22:52 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java4/</guid>
      <description>题目：
输入一个链表，按链表从尾到头的顺序返回一个ArrayList
示例：
 输入： {67,0,24,58} 返回： [58,24,0,67]  思路：
借助栈来实现。
Java实现：
/** * public class ListNode { * int val; * ListNode next = null; * * ListNode(int val) { * this.val = val; * } * } * */ import java.util.*; public class Solution { public ArrayList&amp;lt;Integer&amp;gt; printListFromTailToHead(ListNode listNode) { ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;(); Stack s = new Stack(); while(listNode != null){ s.push(listNode.val); listNode = listNode.next; } while(!</description>
    </item>
    
    <item>
      <title>根据前序中序遍历序列重构二叉树 Java</title>
      <link>https://sherry-long.github.io/post/java3/</link>
      <pubDate>Tue, 09 Feb 2021 13:07:23 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java3/</guid>
      <description>题目：
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
示例：
 输入：[1,2,3,4,5,6,7],[3,2,4,1,6,5,7] 输出：{1,2,5,3,4,6,7}  思路：
因为是树的结构，一般都是用递归来实现。
用数学归纳法的思想就是，假设最后一步，就是root的左右子树都已经重建好了，那么我只要考虑将root的左右子树安上去即可。
根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。
根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。
正如上面所说，只需要将确定的左右子树安到root上即可。递归要注意出口，假设最后只有一个元素了，那么就要返回。
参考来源：https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6
Java实现：
/** * Definition for binary tree * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ import java.util.Arrays; public class Solution { public TreeNode reConstructBinaryTree(int [] pre,int [] in) { if(pre.length == 0) return null; //如果序列为空 返回空节点 	int rootVal = pre[0]; //前序遍历第一个节点必为根节点  if(pre.</description>
    </item>
    
    <item>
      <title>替换字符串空格 Java</title>
      <link>https://sherry-long.github.io/post/java2/</link>
      <pubDate>Tue, 09 Feb 2021 11:04:38 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java2/</guid>
      <description>题目：
请实现一个函数，将一个字符串中的每个空格替换成“%20”。
例如，当字符串为
 We Are Happy.  则经过替换之后的字符串为
 We%20Are%20Happy。  思路：
这种题如果用String来做就会很麻烦，熟悉StringBuffer的相关函数这道题就很简单了。我的思路是这样的，定义一个result(StringBuffer)用来保存结果，将str保存在一个temp数组中，从头到尾遍历数组把temp中的内容写入result中，遇到&#39; &amp;lsquo;就把&amp;quot;%20&amp;quot;用append方法接到result后面，最后将result以String形式返回。
Java实现：
public class Solution { public String replaceSpace(StringBuffer str) { char[] temp = new String(str).toCharArray(); StringBuffer result = new StringBuffer(); for(int index = 0; index &amp;lt; temp.length; ++index) { if(temp[index] == &amp;#39; &amp;#39;) result.append(&amp;#34;%20&amp;#34;); else result.append(temp[index]); } return new String(result); } } 题目来源：剑指offer</description>
    </item>
    
    <item>
      <title>在二维数组中查找指定元素 Java</title>
      <link>https://sherry-long.github.io/post/java1/</link>
      <pubDate>Mon, 08 Feb 2021 12:39:40 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java1/</guid>
      <description>题目：
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例： [1, 2, 8, 9] [2, 4, 9, 12] [4, 7, 10, 13] [6, 8, 11, 15] 思路：
对于这种结构比较特殊的二维数组，使用暴力方法虽然可以解决，效率大大折扣。
我们换一个角度看，每次都看最上面一行和最右面一列。根据本题给出的结构，他是一个递增序列。那么结合这一特点，我们采用二分法来查找。
首先，读取最上面一行和最右面一列，取它们的中间元素，也就是最右上角的元素。如果查找的数小于它，就把列数减少一(此时二维数组变成四行三列)，如果大于就把行数加上一(此时二维数组变成三行四列)，再从新的数组中找出右上角元素进行重复比较，直到找出要查找的数或者数组被“削减”完。
Java实现：
public class Solution { public boolean Find(int target, int [][] array) { int i = 0, j = array[0].length - 1; //i，j分别为行数列数索引，将i的初值设为最上面那一行，j设为最右面那一列  while(i &amp;lt;= array.length - 1 &amp;amp;&amp;amp; j &amp;gt;= 0) { if(array[i][j] == target) return true; //找到target返回true  else if(array[i][j] &amp;lt; target) i++; //array[i][j] &amp;lt; target，i(行)下移  else j--; //array[i][j] &amp;gt; target，j(列)左移  } return false; //未找到元素，返回false  } } 题目来源：剑指offer</description>
    </item>
    
    <item>
      <title>设计一个加法满足100位数相加 Java</title>
      <link>https://sherry-long.github.io/post/java/</link>
      <pubDate>Sun, 07 Feb 2021 12:00:38 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/java/</guid>
      <description>设计一个加法，满足100位数字的相加
思路：将两个加数以字符串形式保存，倒序每位进行加法，进行进位判断，结束之后再按倒序输出
实现：
package test; public class Adder { public static void BigNumSum(String num1, String num2){ // 定义静态函数  char[] numA = new StringBuilder(num1).reverse().toString().toCharArray(); //倒序保存num1的数组形式  char[] numB = new StringBuilder(num2).reverse().toString().toCharArray(); //倒序保存num2的数组形式  int resultLength = Math.max(numA.length, numB.length); //保存两个数的最大位数  int[] result = new int[resultLength + 1]; //定义一个位数为 resultLength + 1 的数组，用来保存结果  for (int i = 0; i &amp;lt; resultLength; ++i) //开始计算  { int Aint = i &amp;lt; numA.</description>
    </item>
    
    <item>
      <title>AVL树 &amp; C语言实现</title>
      <link>https://sherry-long.github.io/post/avltree/</link>
      <pubDate>Wed, 03 Feb 2021 09:32:24 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/avltree/</guid>
      <description>AVL树(平衡二叉树)，是一棵空树，或者是一棵二叉排序树。要介绍AVL树，首先要了解一下二叉排序树的缺点。
当我们向二叉排序树中插入一个有序序列时，它会退化成链表。这样一来我们采用树形结构就没有意义了。为了防止这种情况出现，在插入数据后我们对二叉排序树进行一些结构上的调整，虽然增加了操作复杂度，却减少了检索时间。
AVL性质：
 1.它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树 2.在 AVL树中任何节点的两个子树的高度最大差为 1  AVL与红黑树的区别：
红黑树也是为了解决二叉排序树结构失衡的问题，那么它和AVL树有什么区别呢？
1.首先，AVL是绝对平衡，在 AVL树中任何节点的两个子树的高度最大差为 1。而红黑树的平衡没有这么严格，它的高度差可能大于 1。红黑树在平衡方面加入了颜色机制，所以在进行结构调整时进行旋转的次数要小于AVL，红黑树是在空间和时间效率上的权衡。
2.红黑树的查询性能略微逊色于AVL树，因为其比AVL树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较，但是，红黑树在插入和删除上优于AVL树，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多。
3.AVL树结构更加直观，读取效率更高，维护开销较大；红黑树读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。
4.在查询次数远大于插入删除的情况下采用AVL更好，在查询插入删除都比较频繁的情况下采用红黑树更好。
AVL插入：
当我们向一棵AVL树中插入数据时，要时刻注意检查结构是否失衡，如果失衡就要调整结构，其旋转与红黑树类似，但差别也很大，因为AVL树没有颜色标识，所以进行旋转的次数要比红黑树多。
关于AVL树的插入原理网上有很多资料，下方参考文章里也有，此处不再赘述。详情见下面代码注释
C语言实现：
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;malloc.h&amp;gt; typedef struct AVLNode{ int data; struct AVLNode *r_child, *l_child; int height; }AVLNode, *AVLTree; //AVL树节点  int MAX(int a, int b){ //取ab最大值  return a &amp;gt; b ? a : b; } int Height(AVLTree t){ //求树高，若树为空返回-1  if(t == NULL) return -1; else return t-&amp;gt;height; } AVLNode *AVL_leftRotate(AVLNode *p){ //AVL树左旋(以p为根节点的子树)  AVLNode *s = p-&amp;gt;r_child; //s指向p的右孩子  p-&amp;gt;r_child = s-&amp;gt;l_child; //将s的左孩子接到p的右孩子位置  s-&amp;gt;l_child = p; //p成为s的左孩子  p-&amp;gt;height = MAX(Height(p-&amp;gt;r_child), Height(p-&amp;gt;l_child)) + 1; s-&amp;gt;height = MAX(Height(s-&amp;gt;r_child), Height(s-&amp;gt;l_child)) + 1; //重新计算树高  return s; //返回调整后的根节点 } AVLNode *AVL_rightRotate(AVLNode *p){ //AVL树右旋  AVLNode *s = p-&amp;gt;l_child; p-&amp;gt;l_child = s-&amp;gt;r_child; s-&amp;gt;r_child = p; p-&amp;gt;height = MAX(Height(p-&amp;gt;r_child), Height(p-&amp;gt;l_child)) + 1; s-&amp;gt;height = MAX(Height(s-&amp;gt;r_child), Height(s-&amp;gt;l_child)) + 1; return s; } AVLTree AVL_insert(AVLTree t, int data){ //AVL树插入  if(t == NULL) //如果AVL树是空的，新建一个节点，并置树高为0  { t = (AVLNode *)malloc(sizeof (AVLNode)); t-&amp;gt;data = data; t-&amp;gt;l_child = t-&amp;gt;r_child = NULL; t-&amp;gt;height = 0; } else if (data &amp;lt; t-&amp;gt;data){ //如果data小于t节点的data，插入到它的左子树  t-&amp;gt;l_child = AVL_insert(t-&amp;gt;l_child, data); if(Height(t-&amp;gt;l_child) - Height(t-&amp;gt;r_child) == 2){ //插入完成后，检查结构是否失衡(当向左子树插入data时，只有可能会出现这种情况)  if(data &amp;lt; t-&amp;gt;l_child-&amp;gt;data) //如果是插入到左子树的左子树 (左左情况)  t = AVL_rightRotate(t); //对t进行一次右旋  else if(data &amp;gt; t-&amp;gt;l_child-&amp;gt;data) //左右情况  { t-&amp;gt;l_child = AVL_leftRotate(t-&amp;gt;l_child); //先对t的左子树进行一次左旋  t = AVL_rightRotate(t); //再对t进行一次右旋  } } } else if (data &amp;gt; t-&amp;gt;data){ //参考上方  t-&amp;gt;r_child = AVL_insert(t-&amp;gt;r_child, data); if(Height(t-&amp;gt;r_child) - Height(t-&amp;gt;l_child) == 2){ if(data &amp;gt; t-&amp;gt;r_child-&amp;gt;data) //右右情况  t = AVL_leftRotate(t); else if(data &amp;lt; t-&amp;gt;r_child-&amp;gt;data){ //右左情况  t-&amp;gt;r_child = AVL_rightRotate(t-&amp;gt;r_child); t = AVL_leftRotate(t); } } } t-&amp;gt;height = MAX(Height(t-&amp;gt;l_child), Height(t-&amp;gt;r_child)) + 1; //重新计算树高  return t; //返回t节点 } void AVL_inorder(AVLNode *t){ //中序遍历打印AVL树  if(t !</description>
    </item>
    
    <item>
      <title>红黑树 &amp; C语言实现插入</title>
      <link>https://sherry-long.github.io/post/rbtree/</link>
      <pubDate>Sun, 31 Jan 2021 09:48:38 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/rbtree/</guid>
      <description>红黑树是树型结构中难度比较高的一种，面试当中也频频出现相关问题，从JDK的Hashmap到手撕红黑树，所以深入了解红黑树还是有必要的。
红黑树是一种自平衡的二叉排序树，每当它的结构发生改变时(插入或删除)，如果破坏了红黑树的性质，它就会通过变色、旋转操作来调整结构重新达到平衡。
红黑树的性质：
 1.每个节点都有颜色，不是红的就是黑的 2.根节点为黑色 3.红节点的孩子必为黑节点(不会出现两个连续的红节点) 4.任一结点不管通过什么路径，到达叶子节点的黑结点数目一定相同 5.叶子节点一定为颜色为黑色的NIL节点  红黑树插入：
 首先，红黑树是一种二叉排序树，所以先按照二叉排序树的插入方法进行插入 插入后将节点颜色着成红色(否则会违背 性质4 ，少违背一条性质就意味着我们待会处理的事情越少) 这时若依然违背性质，就对红黑树的结构进行调整重新达成平衡  左旋和右旋：
旋转分为左旋和右旋，当对一个节点进行左旋时，意味着将该结点将成为它右孩子的左孩子，同样的，右旋意味着该节点将成为它左孩子的右孩子
代码实现：
void leftRotate(RBtree *t, Node *p){ //左旋函数  Node *s = p-&amp;gt;r_child; //将s指向待调整节点的右孩子  p-&amp;gt;r_child = s-&amp;gt;l_child; //s的左孩子成为p的右孩子  if(s-&amp;gt;l_child != t-&amp;gt;NIL) s-&amp;gt;l_child-&amp;gt;parent = p; //如果s的左孩子不是NIL节点(s的左孩子存在)，遂改该节点的父节点为p  s-&amp;gt;parent = p-&amp;gt;parent; // 接下来调整s取代p的位置  if(p-&amp;gt;parent == t-&amp;gt;NIL) t-&amp;gt;root = s; //如果p为根节点，s成为根节点  else if(p == p-&amp;gt;parent-&amp;gt;l_child) p-&amp;gt;parent-&amp;gt;l_child = s; //如果p为其父节点的左孩子，s取代其位置  else p-&amp;gt;parent-&amp;gt;r_child = s; //如果p为其父节点的右孩子，s取代其位置  s-&amp;gt;l_child = p; //p成为s的左孩子  p-&amp;gt;parent = s; //s成为p的父节点 } void rightRotate(RBtree *t, Node *p){ //右旋函数，过程与左旋类似，方向相反  Node *s = p-&amp;gt;l_child; p-&amp;gt;l_child = s-&amp;gt;r_child; if(s-&amp;gt;r_child !</description>
    </item>
    
    <item>
      <title>二叉排序树 &amp; C语言实现</title>
      <link>https://sherry-long.github.io/post/bstree/</link>
      <pubDate>Fri, 29 Jan 2021 11:12:54 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/bstree/</guid>
      <description>二叉排序树，又称为二叉查找树，具有以下性质：
 (1)若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； (2)若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值； (3)它的左、右子树也分别为二叉排序树。  根据这些性质我们可以知道，一棵二叉排序树的中序遍历序列一定是有序且升序的。
插入:
1.插入过程比较简单，首先判断当前要插入的值是否已经存在二叉排序树中，如果已经存在，则直接返回；如果不存在，则转2;
2.当前要插入的值不存在，则应找到适当的位置，将其插入。注意插入的新节点一定是叶子节点;
查找:
按以下逻辑进行递归查找
while(该节点不为空 &amp;amp;&amp;amp; 该节点值 != 插入值){ if(该节点值 &amp;lt; 插入值) 查找他的右子树 else if(节点值 &amp;gt; 插入值) 查找他的左子树 } 实现:
typedef struct BiTNode{ int data; struct BiTNode *l_child,*r_child; }BiTNode,*BiTree; //定义数据结构  void InOrder(BiTNode *p) //中序遍历 { if(p != NULL) { InOrder(p-&amp;gt;l_child); printf(&amp;#34; %d &amp;#34;,p-&amp;gt;data); InOrder(p-&amp;gt;r_child); } } BiTNode *createNode(int key) //建立新结点并返回 { BiTNode *temp = (BiTNode *)malloc(sizeof(BiTNode)); temp-&amp;gt;data = key; temp-&amp;gt;l_child = temp-&amp;gt;r_child = NULL; return temp; } bool BST_search(BiTNode *bst, int key, BiTNode *before, BiTree *p) //查找 { if (!</description>
    </item>
    
    <item>
      <title>动态规划-最长公共子序列</title>
      <link>https://sherry-long.github.io/post/lcs/</link>
      <pubDate>Thu, 28 Jan 2021 12:47:54 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/lcs/</guid>
      <description>动态规划的主要思想是，将待解问题分解成很多规模更小的具有相同结构的子问题，即最优子结构，然后通过分别对这些子问题求解来解决最终问题。
它与分治法的主要不同点在于，动态规划分解得到子问题往往不是互相独立的。我们会保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。
我们可以用一个表来记录所有已解的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。
接下来我们来看一个比较经典的题目，最长公共子序列问题(LCS)。
问题：给出两个字符串，求出这两个字符串的LCS。(LCS：比如对于&amp;quot;A, B, D, C, E&amp;quot;和&amp;quot;A, Y, D, E, X&amp;quot;两个串来说，他们的LCS就是&amp;quot;A, D, E&amp;quot;)
求解这一问题前我们需要深入理解一下LCS，分析一下它能不能用动态规划来解决以及用动态规划的优势在哪里。
假设对于 X[m] 和 Y[n] 两个串，我要找他们两个的LCS。先假设他们的LCS为Z，如果我们从两个串的最后一个元素看起，X.m 和 Y.n ，如果 X.m ≠ Y.n ，那么Z一定也是 X[m-1] 与 Y[n] 或 X[m] 与 Y[n-1] 的LCS
换一种说法，令X = {x1, x2, &amp;hellip;, xm}, Y = {y1, y2, &amp;hellip;, yn} 为两个序列，Z = {z1, z2, &amp;hellip;, zk} 为他们的任意LCS(之所以任意，是因为两个序列的LCS可能不止一个)
 1.如果xm = yn，则 zk = xm = yn 且 Z[k-1] 是 X[m-1] 和 Y[n-1] 的一个LCS 2.</description>
    </item>
    
    <item>
      <title>字典树 &amp; Java实现</title>
      <link>https://sherry-long.github.io/post/trietree/</link>
      <pubDate>Thu, 28 Jan 2021 10:19:57 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/trietree/</guid>
      <description>字典树：
又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。
它有3个基本性质：
1.根节点不包含字符，除根节点外每一个节点都只包含一个字符
2.从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串
3.每个节点的所有子节点包含的字符都不相同
以一个英文单词字典树为例，它的每个节点都有最多26个子节点，代表26个英文字母。如果不了解哈希树可以想想huffman树，当我们在找一个指令的huffman编码时，我们从 根结点出发，往下找到代表该指令的叶结点，路径上经过的节点连起来便是它的huffman编码。
字典树也是类似原理，只不过huffman树每个节点有两个子节点，一个代表0、一个代表1，而字典树每个节点有26个子节点(以英文字典树为例)，我们想找一个单词时，就一个字母一个字母的 从根节点往下找，所有字母找完后检查最后一个字母是否为一个单词的结尾(isEnd标志位)，如果是就查找成功。
Java实现：
// 成员变量 	final static int MAX_LENGTH = 26; //最大长度  char data; //节点数据  boolean isEnd; // 从根节点到此节点所经过的路径是否构成一个完整的单词(是否是一个单词的结尾)  TreeNode[] childs; // 构造方法 	TreeNode(){ childs = new TreeNode[MAX_LENGTH]; isEnd = false; } // 成员方法 	public void createTrieTree(String str, TreeNode node){ //插入节点  char[] temp = str.toCharArray(); for(int i = 0; i &amp;lt; str.length(); ++i){ int location = temp[i] - &amp;#39;a&amp;#39;; // 将字母转成0~25的数字，方便索引  if(node.</description>
    </item>
    
    <item>
      <title>计算机网络-TCP三次握手四次挥手</title>
      <link>https://sherry-long.github.io/post/net/</link>
      <pubDate>Wed, 27 Jan 2021 10:11:23 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/net/</guid>
      <description>TCP是面向连接的可靠通信协议，在两端主机进行通信前，会先建立逻辑连接，而在结束通信时会断开连接，也就是我们所说的“三次握手”，“四次挥手”
为什么要握手三次呢？
比较官方的回答自然是，防止确认帧丢失，导致一方误以为确认帧送达而耗费资源
这样说更容易理解：
两台主机A、B要进行通信，根据TCP协议原则，A要给B发送SYN帧请求建立连接，B收到了，那么对于B来说，B就知道了A具有发送数据的能力， 这时B给A回发ACK帧，A收到了，那么对于A来说，A此时知道了B具有接受数据和发送数据的能力。此时还有一个问题，B不知道A有没有 接受数据的能力啊，要是直接给A发数据，他收不到那我岂不是白发了。那么这时A再给B回一个ACK帧，B知道A可以接受自己发给他的数据了， 就可以解决这一问题了。
其实本质上就是防止确认帧丢失，只不过这样解释感觉更好理解
为什么要挥手四次呢？
比如A没有东西要发给B了，想断开连接了。A向B发送了FIN帧(第一次挥手)请求结束，但是B可能还有数据没有传完，在建立连接时，可以将SYN和ACK两个标志 一起传输，是因为确认和同步本身没冲突，但是在关闭连接时，双方不一定数据都传送完了，这时如果FIN+ACK就可能会产生问题。所以B就先告诉A，好我知道 你发完了(第二次挥手)，我确认收到了你的FIN，但是我这边还有东西要给你，所以我的FIN要待会发给你。B继续向A传输数据，最后B也发完了，B就跟A说，我 也没东西给你了，我们可以分手了(FIN，第三次挥手)，A收到后：好的，我收到了，可以分手了(ACK，第四次挥手)。
挥手四次完毕后，A(发起结束方)还要继续等待2MSL(最大报文段生存时间)才能close，为什么？
以上所有都是理想状态，谁知道实际会出现什么问题，有可能最后一次ACK就丢失了呢。如果不等这段时间，那最后的确认帧要是丢失了，B等了半天也不见A的确认， 反复给A重传结束帧，A这边又早就已经进入close状态，就会白白浪费资源，这是其一。
其二，双方结束了连接，在数据通路中还是有可能会残留一些数据报，这2MSL就是确保这些“丝”彻底断掉，不占用资源。</description>
    </item>
    
    <item>
      <title>单链表 C实现</title>
      <link>https://sherry-long.github.io/post/linkedlist/</link>
      <pubDate>Tue, 26 Jan 2021 21:23:25 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/linkedlist/</guid>
      <description>单链表
数据结构
typedef struct LinkNode{ int data; struct LinkNode *next; }LinkNode,*LinkList; 函数：
尾插：
void List_Tinsert(LinkNode *p,int num) //尾插法 { LinkNode *s = p; while (s-&amp;gt;next) s = s-&amp;gt;next; LinkNode *r = (LinkNode *)malloc(sizeof(LinkNode)); r-&amp;gt;data = num; r-&amp;gt;next = NULL; s-&amp;gt;next = r; } 头插：
void List_Hinsert(LinkNode *p,int num) //头插法 { LinkNode *s; s = (LinkNode *)malloc(sizeof(LinkNode)); s-&amp;gt;data = num; s-&amp;gt;next = p-&amp;gt;next; p-&amp;gt;next = s; } 链表创建（从1到n按序生成）
void List_create(LinkNode *p,int n) { for(int i = 1;i &amp;lt;= n;++i) List_Tinsert(p,i); //从1到n，尾插生成  printf(&amp;#34;Creation complete!</description>
    </item>
    
    <item>
      <title>堆排序原理 &amp; C语言实现</title>
      <link>https://sherry-long.github.io/post/heapsort/</link>
      <pubDate>Tue, 26 Jan 2021 21:20:38 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/heapsort/</guid>
      <description>堆排序
首先说一下堆，它可以被视为完全二叉树，大（小）根堆即任意非根结点的值都小（大）于等于其双亲结点的值。
基本原理：建立大（小）根堆，依次将堆顶元素与堆底元素进行交换，每次交换完成后堆大小减一，重复此过程，直到数组中只剩下一个元素为止。
算法框架如下
void HeapSort(int *A,int n)	//此处预留A[0],所以参数n应为数组A的大小减1 { BuildMaxHeap(A,n);	//首先建立大根堆  for (int i = n;i &amp;gt; 1;--i) { swap(&amp;amp;A[i],&amp;amp;A[1]); HeapAdjust(A,1,i - 1); }	//每次循环将当前堆顶元素与堆底元素交换，此时堆性质可能会被破坏，  //调用HeapAdjust方法将堆重新调整有序 } 此处将A数组的第一个元素（A[0]）预留出来，后续有用 也就是说n个元素需要一个大小为n+1的数组
建立大根堆：
void BuildMaxHeap(int *A,int n) { for (int i = n / 2;i &amp;gt; 0;--i) { HeapAdjust(A,i,n); } } 很简单的几行代码，原理也很简单 学习过二叉树，我们知道：对于一个完全二叉树来说，它的最后一个节点是第 n/2（向下取整） 个节点的子节点。 比如说一个完全二叉树有五个节点，那么它的第五个节点就是第二个节点的子节点。 对以此节点为根的子树进行调整，使该子树成为堆。此后依次向前对各节点进行调整（n/2（向下取整）到1），直到根节点，使整个树成为堆。
堆调整
void HeapAdjust(int *A,int i,int n) { A[0] = A[i];	//将待调整节点值存放至A[0]中  for(int j = i * 2;j &amp;lt;= n;j *= 2)	//找到i节点的孩子节点j，并沿子节点向下调整  { if(j &amp;lt; n &amp;amp;&amp;amp; A[j] &amp;lt; A[j + 1])	//如果j有兄弟节点，并且	 j++;	//小于其兄弟节点，将j指向兄弟节点  //（也就是找到i的孩子节点中最大的那个，如果建立的是小根堆就是找到最小的那个）  if(A[j] &amp;gt; A[0]) { A[i] = A[j]; i = j; }	//如果i的孩子节点比j大，A[j]放到A[i]的位置上  //并将j作为下一个调整的节点，向下继续调整  else break;	//如果堆性质未被破坏则直接跳出循环  } A[i] = A[0];	//最终将A[i]放到它该在的地方（如堆性质未被破坏则还在原位置） } 堆排序，说白了就是将堆顶元素（最大元素）输出，将堆中的剩余元素重新调整有序，再将堆顶元素（此时为第二大元素）输出，循环此过程</description>
    </item>
    
    <item>
      <title>第二次测试</title>
      <link>https://sherry-long.github.io/post/blog2/</link>
      <pubDate>Tue, 26 Jan 2021 13:52:24 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/blog2/</guid>
      <description>this is another test</description>
    </item>
    
    <item>
      <title>测试</title>
      <link>https://sherry-long.github.io/post/blog1/</link>
      <pubDate>Tue, 26 Jan 2021 13:20:28 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/blog1/</guid>
      <description>this is a test</description>
    </item>
    
  </channel>
</rss>
