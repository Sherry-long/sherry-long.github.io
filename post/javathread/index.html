<!doctype html>
<html lang="en-us">
  <head>
    <title>Java线程1 // Sp(act)rum</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="冯雪洋" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://sherry-long.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java线程1"/>
<meta name="twitter:description" content="进程与线程 进程是资源分配的单位，线程是调度和执行的单位 线程是进程的一个执行单元，一个线程就是进程中一个单一的控制流
进程是线程的容器，一个进程至少有一个线程，一个进程中也可以有多个线程
并发与并行 并行是指两个或者多个事件在同一时刻发生，而并发是指两个或多个事件在同一时间间隔发生。
并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
使用多线程的优点   1.提高应用程序的响应速度。对图形化界面更有意义，可增强用户体验
  2.提高计算机系统CPU的利用率
  3.改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改
  何时需要多线程   程序需要同时执行两个或多个任务
  程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等
  需要一些后台运行的程序时
   线程的创建和使用-4种创建方式 可以通过两种方法实现线程类： 1）继承Thread类 ； 2 ）实现Runnable接口
 1） 1. 继承Thread类 2. 重写run方法，run方法内部就是你的线程要做的事情 3. 创建子线程对象 4. 启动线程 thread.start() 调用start()方法来启动线程，启动线程的实质就是请求JVM运行相应线程，这个线程具体在什么时候运行 由线程调度器决定 Scheduler 2） 当线程类已经有父类了，就不能继承Thread类了， 1. 实现Runnable接口，重写run方法，run方法内部就是你的线程要做的事情 2. 创建Runnable接口实现类对象 Myrunnable runnable = new Myrunnable(); 3. 创建线程对象 Thread thread = new Thread(runnable); 4."/>

    <meta property="og:title" content="Java线程1" />
<meta property="og:description" content="进程与线程 进程是资源分配的单位，线程是调度和执行的单位 线程是进程的一个执行单元，一个线程就是进程中一个单一的控制流
进程是线程的容器，一个进程至少有一个线程，一个进程中也可以有多个线程
并发与并行 并行是指两个或者多个事件在同一时刻发生，而并发是指两个或多个事件在同一时间间隔发生。
并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
使用多线程的优点   1.提高应用程序的响应速度。对图形化界面更有意义，可增强用户体验
  2.提高计算机系统CPU的利用率
  3.改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改
  何时需要多线程   程序需要同时执行两个或多个任务
  程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等
  需要一些后台运行的程序时
   线程的创建和使用-4种创建方式 可以通过两种方法实现线程类： 1）继承Thread类 ； 2 ）实现Runnable接口
 1） 1. 继承Thread类 2. 重写run方法，run方法内部就是你的线程要做的事情 3. 创建子线程对象 4. 启动线程 thread.start() 调用start()方法来启动线程，启动线程的实质就是请求JVM运行相应线程，这个线程具体在什么时候运行 由线程调度器决定 Scheduler 2） 当线程类已经有父类了，就不能继承Thread类了， 1. 实现Runnable接口，重写run方法，run方法内部就是你的线程要做的事情 2. 创建Runnable接口实现类对象 Myrunnable runnable = new Myrunnable(); 3. 创建线程对象 Thread thread = new Thread(runnable); 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sherry-long.github.io/post/javathread/" />
<meta property="article:published_time" content="2022-08-29T09:22:08+08:00" />
<meta property="article:modified_time" content="2022-08-29T09:22:08+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://sherry-long.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="冯雪洋" /></a>
      <h1>Sp(act)rum</h1>
      <p>这个人很懒，什么介绍都没留下</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/Sherry-long" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://space.bilibili.com/13547597" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java线程1</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Aug 29, 2022
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h2 id="进程与线程">进程与线程</h2>
<h5 id="进程是资源分配的单位线程是调度和执行的单位">进程是资源分配的单位，线程是调度和执行的单位</h5>
<p>线程是进程的一个执行单元，一个线程就是进程中一个单一的控制流</p>
<p>进程是线程的容器，一个进程至少有一个线程，一个进程中也可以有多个线程</p>
<h5 id="并发与并行">并发与并行</h5>
<p>并行是指两个或者多个事件在同一时刻发生，而并发是指两个或多个事件在同一时间间隔发生。</p>
<p>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</p>
<h5 id="使用多线程的优点">使用多线程的优点</h5>
<ul>
<li>
<p>1.提高应用程序的响应速度。对图形化界面更有意义，可增强用户体验</p>
</li>
<li>
<p>2.提高计算机系统CPU的利用率</p>
</li>
<li>
<p>3.改善程序结构，将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</p>
</li>
</ul>
<h5 id="何时需要多线程">何时需要多线程</h5>
<ul>
<li>
<p>程序需要同时执行两个或多个任务</p>
</li>
<li>
<p>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</p>
</li>
<li>
<p>需要一些后台运行的程序时</p>
</li>
</ul>
<hr>
<h3 id="线程的创建和使用-4种创建方式">线程的创建和使用-4种创建方式</h3>
<p>可以通过两种方法实现线程类： 1）继承Thread类 ； 2 ）实现Runnable接口</p>
<pre><code>        1）
        1. 继承Thread类
        2. 重写run方法，run方法内部就是你的线程要做的事情
        3. 创建子线程对象
        4. 启动线程 thread.start()
            调用start()方法来启动线程，启动线程的实质就是请求JVM运行相应线程，这个线程具体在什么时候运行
            由线程调度器决定 Scheduler
			
        2）
        当线程类已经有父类了，就不能继承Thread类了，
        1. 实现Runnable接口，重写run方法，run方法内部就是你的线程要做的事情
        2. 创建Runnable接口实现类对象 Myrunnable runnable = new Myrunnable();
        3. 创建线程对象 Thread thread = new Thread(runnable);
        4. 开启线程 thread.start();
	
    第三步可以通过传递匿名内部类实现
</code></pre>
<h5 id="注意">注意：</h5>
<h5 id="不可直接调用run方法否则将被视为寻常的方法调用不会启用多线程">不可直接调用run()方法，否则将被视为寻常的方法调用，不会启用多线程</h5>
<h5 id="start方法调用结束并不代表子线程开始运行">start()方法调用结束并不代表子线程开始运行</h5>
<h5 id="新开启的线程会执行run方法">新开启的线程会执行run()方法</h5>
<h5 id="如果开启了多个线程start调用的顺序并不一定就是线程启动的顺序">如果开启了多个线程，start()调用的顺序并不一定就是线程启动的顺序</h5>
<h5 id="多线程运行结果与代码执行顺序调用顺序无关">多线程运行结果与代码执行顺序(调用顺序)无关</h5>
<h4 id="多线程运行结果有随机性">多线程运行结果有随机性</h4>
<h3 id="比较创建线程的两种方式">比较创建线程的两种方式</h3>
<p>优先选择实现Runnable接口的方式</p>
<p>原因：
1. 实现的方式没有类的单继承性限制</p>
<pre><code>    2. 实现的方式更适合处理多个线程有共享数据的情况
</code></pre>
<p>Thread类本身也是实现了Runnable</p>
<p>两种方式都需要重写run()方法</p>
<hr>
<h3 id="线程的常用方法">线程的常用方法</h3>
<h5 id="void-start--启动线程">void start() : 启动线程</h5>
<h5 id="run--线程在被调度时执行的操作">run() : 线程在被调度时执行的操作</h5>
<h5 id="string-getname--返回当前线程的名称">String getName() : 返回当前线程的名称</h5>
<h5 id="void-setnamestring-name--设置该线程的名称">void setName(String name) : 设置该线程的名称</h5>
<h5 id="static-thread-currentthread--返回当前线程在thread子类中就是this通常用于主线程和runnable实现类">static Thread currentThread() : 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类</h5>
<h5 id="static-void-yield--线程让步">static void yield() : 线程让步</h5>
<p>暂停当前正在执行的线程，把执行机会让给优先级更高或相同的线程。若队列中没有同优先级的线程，忽略此方法</p>
<h5 id="void-join--等待线程执行完毕">void join() : 等待线程执行完毕</h5>
<p>当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完为止</p>
<ul>
<li>低优先级的线程也可以获得执行</li>
</ul>
<p><em>join()方法内部使用了wait()方法</em></p>
<h5 id="static-void-sleeplong-millis--指定时间毫秒">static void sleep(long millis) : (指定时间：毫秒)</h5>
<p>令当前活动线程在指定时间段内放弃对CPU控制，时间到后重排队</p>
<h5 id="stop--强制线程生命期结束不推荐使用">stop() : 强制线程生命期结束，不推荐使用</h5>
<p>stop会强制杀死线程，如果此时线程锁住了某些共享资源，他就没机会释放这些资源的锁，这些资源就不能再被其他线程获取到，推荐使用interrupt()方法结合打断标记来停止一个线程</p>
<h5 id="boolean-isalive--判断线程是否存活">boolean isAlive() : 判断线程是否存活</h5>
<h5 id="void-interrupt--打断线程">void interrupt() : 打断线程</h5>
<p>此方法会将线程打断标记置为true，但是并不会真正使线程停止，只是告诉线程我要打断你，再由线程自己去停止</p>
<h5 id="boolean-isinterrupted--结合上面interrupt方法使用判断线程是否被打断再去手动停止线程">boolean isInterrupted() : 结合上面interrupt()方法使用，判断线程是否被打断，再去手动停止线程</h5>
<h5 id="static-boolean-interrupted--此方法是thread类中的静态方法它会返回线程的打断标记并重置标记true---false">static boolean interrupted() : 此方法是Thread类中的静态方法，它会返回线程的打断标记并重置标记(true -&gt; false)</h5>
<pre><code>打断正在sleep(), wait(), join()的线程，打断标记会重置为false(有一定延迟，打断后立刻判断标记是true，等待一段时间判断为false)
打断正常运行的线程打断标记会置为true
</code></pre><hr>
<h3 id="线程的生命周期">线程的生命周期</h3>
<hr>
<h1 id="线程的同步线程安全-3种解决方式">线程的同步(线程安全)-3种解决方式</h1>
<h3 id="主要解决问题多个线程对于临界资源的访问可能因为线程调度引起的访问冲突等问题">主要解决问题：多个线程对于临界资源的访问，可能因为线程调度引起的访问冲突等问题</h3>
<p>当一个线程在操作临界资源的时候，其他线程不能参与进来，直到当前线程操作完临界资源后，其他线程才可操作。即使当前线程被阻塞，也不能改变。</p>
<hr>
<h3 id="在java中我们通过同步机制来解决线程问题">在Java中我们通过同步机制来解决线程问题</h3>
<h4 id="方式一-同步代码块">方式一： 同步代码块</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">synchronized</span><span style="color:#f92672">(</span>同步监视器<span style="color:#f92672">){</span>
	<span style="color:#75715e">//需要被同步的代码，不能多不能少
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>说明：操作临界资源的代码即为需要被同步的代码。同步监视器：俗称 锁 ，任何一个类的对象都可以充当 锁 。多个线程必须共用一把锁(同一个对象)</p>
<ul>
<li>
<p>当采用实现类的方式创建线程时，可使用 this 作为同步监视器。因为只需要创建一个实现类对象，通过此实现类去构造不同线程，实现类对象只有一个，</p>
<p>所以可以作为锁。</p>
</li>
<li>
<p>当采用继承Thread类的方式创建线程时，可使用 线程类名.class 作为锁(类也是对象)</p>
</li>
</ul>
<hr>
<h4 id="方式二-同步方法">方式二： 同步方法</h4>
<p>如果操作临界资源的代码完整的声明在一个方法中，将这个方法声明为同步的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">operate</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tickets <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> tickets<span style="color:#f92672">);</span>
            tickets<span style="color:#f92672">--;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><ul>
<li>
<p>当采用实现类的方式创建线程时，默认锁为 this</p>
<p>所以可以作为锁。</p>
</li>
<li>
<p>当采用继承Thread类的方式创建线程时，要将方法声明为静态的，此时默认锁不再为 this，而是是当前类本身 线程类名.class</p>
</li>
</ul>
<hr>
<h4 id="方法三-lock锁-reentrantlock类">方法三： Lock(锁) ReentrantLock类</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Window4</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> tickets <span style="color:#f92672">=</span> 100<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> ReentrantLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock<span style="color:#f92672">();</span><span style="color:#75715e">//定义ReentrantLock对象
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span> <span style="color:#75715e">//在临界资源操作前调用lock()方法上锁，并用try将方法调用语句和临界资源操作代码包含起来
</span><span style="color:#75715e"></span>                lock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tickets <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                    <span style="color:#f92672">}</span>
                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">+</span> tickets<span style="color:#f92672">);</span>
                    tickets<span style="color:#f92672">--;</span>
                <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span> <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span> <span style="color:#75715e">//在finally语句中调用unlock()方法解锁
</span><span style="color:#75715e"></span>                lock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><hr>
<h3 id="synchronized关键字-与-reentrantlock类-的异同">synchronized关键字 与 ReentrantLock类 的异同</h3>
<p>都是用来解决线程安全问题的</p>
<p>Lock需要自己手动启动同步(lock方法)以及结束同步(unlock方法)，sync执行完相应的同步代码或方法后自动释放同步监视器</p>
<h3 id="lock更灵活一些优先使用顺序">Lock更灵活一些，优先使用顺序：</h3>
<p>Lock -&gt; 同步代码块(已经进入了方法体，分配了相应资源) -&gt; 同步方法(在方法体之外)</p>
<hr>
<hr>
<h3 id="线程通信">线程通信</h3>
<h5 id="objectwait-causes-the-current-thread-to-wait-until-it-is-awakened-typically-by-being-notified-or-interrupted">Object.wait() :Causes the current thread to wait until it is awakened, typically by being notified or interrupted.</h5>
<p>调用此方法会导致当前线程阻塞，直至其被唤醒(被 notify 或被 interrupt )</p>
<h5 id="objectnotify-wakes-up-a-single-thread-that-is-waiting-on-this-objects-monitor-if-any-threads-are-waiting-on-this-object-one-of-them-is-chosen-to-be-awakened">Object.notify() :Wakes up a single thread that is waiting on this object&rsquo;s monitor. If any threads are waiting on this object, one of them is chosen to be awakened.</h5>
<p>唤醒一个正在等待这个对象的锁的线程，被唤醒的线程不会立刻执行，直到当前线程释放锁</p>
<h5 id="objectnotifyall-wakes-up-all-threads-that-are-waiting-on-this-objects-monitor">Object.notifyAll() :Wakes up all threads that are waiting on this object&rsquo;s monitor.</h5>
<p>唤醒所有等待当前对象的锁的线程，这些线程将会按照正常方式竞争，被唤醒的线程不会立刻执行，直到当前线程释放锁</p>
<h3 id="以上方法均须在使用-synchronized-关键字同步代码块同步方法的前提下使用reentrantlock不可">以上方法均须在使用 synchronized 关键字(同步代码块、同步方法)的前提下使用，ReentrantLock不可</h3>
<h3 id="且以上三个方法的调用者都必须为同步代码块同步方法的同步监视器锁">且以上三个方法的调用者都必须为(同步代码块、同步方法)的同步监视器(锁)</h3>
<hr>
<hr>
<h3 id="sleep-与-wait-的异同">sleep() 与 wait() 的异同？</h3>
<ul>
<li>
<p>相同点：都会使调用方法的线程进入阻塞状态</p>
</li>
<li>
<p>不同点：</p>
<pre><code>  1. sleep()方法声明在Thread类中，且为静态方法；wait()方法声明在Object类中
  2. 使用要求不同：sleep()可以在任何需要的场景调用；wait()必须在synchronized关键字的影响范围内使用
     (同步代码块或者同步方法)
  3. 如果两个方法都使用在同步代码块或者同步方法中，sleep()不会释放同步监视器，wait()会释放
</code></pre>
</li>
</ul>
<h3 id="生产者消费者问题">生产者消费者问题：</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PCTest</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Clerk clerk <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Clerk<span style="color:#f92672">();</span>

        Producer producer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Producer<span style="color:#f92672">(</span>clerk<span style="color:#f92672">);</span>
        Consumer consumer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Consumer<span style="color:#f92672">(</span>clerk<span style="color:#f92672">);</span>

        Thread thread1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>producer<span style="color:#f92672">);</span>
        Thread thread2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>consumer<span style="color:#f92672">);</span>
        Thread thread3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>producer<span style="color:#f92672">);</span>
        Thread thread4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>consumer<span style="color:#f92672">);</span>

        thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;producer-1 Thread:&#34;</span><span style="color:#f92672">);</span>
        thread2<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;consumer-1 Thread:&#34;</span><span style="color:#f92672">);</span>
        thread3<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;producer-2 Thread:&#34;</span><span style="color:#f92672">);</span>
        thread4<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;consumer-2 Thread:&#34;</span><span style="color:#f92672">);</span>

        thread1<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        thread2<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        thread3<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
        thread4<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Clerk</span> <span style="color:#f92672">{</span><span style="color:#75715e">//临界资源类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> products <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">GetFromP</span><span style="color:#f92672">(){</span><span style="color:#75715e">//从生产者处获取资源
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>products <span style="color:#f92672">&lt;</span> 20<span style="color:#f92672">){</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
                products<span style="color:#f92672">++;</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; produced a product, product:&#34;</span> <span style="color:#f92672">+</span> products<span style="color:#f92672">);</span>
                notify<span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    wait<span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DeliverToC</span><span style="color:#f92672">(){</span><span style="color:#75715e">//给消费者提供资源
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">synchronized</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>products <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">){</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>100<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
                products<span style="color:#f92672">--;</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; consumed a product, product:&#34;</span> <span style="color:#f92672">+</span> products<span style="color:#f92672">);</span>
                notify<span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span><span style="color:#66d9ef">else</span><span style="color:#f92672">{</span>
                <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                    wait<span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Producer</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span><span style="color:#75715e">//生产者类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Clerk clerk<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Producer</span><span style="color:#f92672">(</span>Clerk clerk<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clerk</span> <span style="color:#f92672">=</span> clerk<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            clerk<span style="color:#f92672">.</span><span style="color:#a6e22e">GetFromP</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Consumer</span> <span style="color:#66d9ef">implements</span> Runnable <span style="color:#f92672">{</span><span style="color:#75715e">//消费者类
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Clerk clerk<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Consumer</span><span style="color:#f92672">(</span>Clerk clerk<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clerk</span> <span style="color:#f92672">=</span> clerk<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            clerk<span style="color:#f92672">.</span><span style="color:#a6e22e">DeliverToC</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><hr>
<hr>
<h3 id="jdk50新增线程创建方式">JDK5.0新增线程创建方式</h3>
<h4 id="实现callable接口">实现Callable接口</h4>
<ul>
<li>
<p>与使用Runnable接口相比，Callable功能更强大些</p>
<pre><code>  相比run()方法，可以有返回值
  方法可以抛出异常
  支持泛型的返回值
  需要借助FutureTask类，比如获取返回结果
</code></pre>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CallTest</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
		<span style="color:#75715e">// 定义一个实现类对象
</span><span style="color:#75715e"></span>        myThread mythread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> myThread<span style="color:#f92672">();</span>
		<span style="color:#75715e">// 使用实现类对象作为参数定义一个FutureTask对象
</span><span style="color:#75715e"></span>        FutureTask futureTask <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FutureTask<span style="color:#f92672">(</span>mythread<span style="color:#f92672">);</span>
		<span style="color:#75715e">// 使用FutureTask对象作为参数定义一个线程，启动线程
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>futureTask<span style="color:#f92672">).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
		<span style="color:#75715e">// 如果需要返回值，则使用futureTask.get()方法来获取返回值，如不需要则无视
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>futureTask<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">());</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>ExecutionException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">myThread</span> <span style="color:#66d9ef">implements</span> Callable <span style="color:#f92672">{</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">call</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i <span style="color:#f92672">%</span> 2 <span style="color:#f92672">==</span> 0<span style="color:#f92672">){</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
                sum <span style="color:#f92672">+=</span> i<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> sum<span style="color:#f92672">;</span><span style="color:#75715e">// 此返回值需要通过FutureTask.get()方法获取
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><h5 id="如何理解-callable-比-runnable-更强大">如何理解 Callable 比 Runnable 更强大</h5>
<ol>
<li>call()方法可以有返回值</li>
<li>call()方法可以抛出异常，被外面的操作捕获，获取异常信息</li>
<li>Callable是支持泛型的</li>
</ol>
<hr>
<h4 id="使用线程池">使用线程池</h4>
<ul>
<li>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</li>
</ul>
<h5 id="思路提前创建好多个线程放入线程池中使用时直接获取使用完放回池中实现重复利用">思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，实现重复利用。</h5>
<h4 id="好处">好处：</h4>
<pre><code>    提高响应速度(减少创建新线程的时间)
    降低资源消耗(重复利用线程池中的线程，不需要每次都创建)
    便于线程管理：corePoolSize：核心池的大小 
                  maximumPoolSize：最大线程数
                  keepAliveTime：线程没有任务时最多存活多长时间
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThreadPool</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//提供指定数量的线程池
</span><span style="color:#75715e"></span>
        ExecutorService service <span style="color:#f92672">=</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
        <span style="color:#75715e">//设置线程池的属性
</span><span style="color:#75715e"></span>

        <span style="color:#75715e">//执行指定线程的操作，需要提供一个实现Runnable或Callable接口的实现类的对象
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//service.execute(Runnable command); 适用于Runnable
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//service.submit(Callable task);  适用于Callable
</span><span style="color:#75715e"></span>        service<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> NumberThread<span style="color:#f92672">());</span>
        service<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> NumberThread1<span style="color:#f92672">());</span>
        <span style="color:#75715e">//关闭连接池
</span><span style="color:#75715e"></span>        service<span style="color:#f92672">.</span><span style="color:#a6e22e">shutdown</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NumberThread</span> <span style="color:#66d9ef">implements</span> Runnable<span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i <span style="color:#f92672">%</span> 2 <span style="color:#f92672">==</span> 0<span style="color:#f92672">){</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NumberThread1</span> <span style="color:#66d9ef">implements</span> Runnable<span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 100<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>i <span style="color:#f92672">%</span> 2 <span style="color:#f92672">==</span> 1<span style="color:#f92672">){</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
