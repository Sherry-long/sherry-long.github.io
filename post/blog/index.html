<!doctype html>
<html lang="en-us">
  <head>
    <title>Java笔记(持续更新) // Sp(act)rum</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://sherry-long.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java笔记(持续更新)"/>
<meta name="twitter:description" content="此笔记为本人在复习巩固Java基础时做的记录，内容很杂，持续更新中
this关键字 创建一个对象时分以下四部： 1.分配对象空间，将对象成员变量初始化为0或空 2.执行显示值的属性初始化 3.执行构造方法 4.返回对象的地址给相关变量 this 指的是“创建好的对象的地址”，在调用构造方法时，对象已被创建，在构造方法中使用this，代表“当前对象” this 用法 1. this.name = name; 避免程序二义 2. 使用this关键字调用重载的构造方法，避免初始化代码重复。 只能在构造方法中使用，只能引用一个，必须位于构造方法的第一句 （在构造器中，如果为this添加了参数列表，那么就有不同的含义。这将产生对符合此参数列表的某个构造器的明确调用） 3. this 不能用于static方法中（因为静态方法不依赖对象来进行访问，没有对象就谈不上this） 4. this 将当前对象本身作为参数传递给其他方法 5. return this; this 将当前对象作为参数返回，这样可以对一个对象进行多次操作  static关键字 当声明一个域或方法是static时，意味着这个域或方法不与包含他的那个类的任何对象关联在一起，与类相关联 方便在没有创建对象的情况下来进行调用（方法/变量） 1. static方法： 静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的 不需要对象便可通过类名进行调用（但是也可以通过对象进行调用） 2. static变量： 静态变量被所有对象共享，在内存中只有一个副本 3. static代码块： 优化程序性能（重复代码块） private static Date startDate,endDate; static{ startDate = Date.valueOf(&quot;1946&quot;); endDate = Date.valueOf(&quot;1964&quot;); } static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的 在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 构造器是static方法，它不需要对象来调用 static不会改变方法和变量的访问权限 静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够） 可用static来实现单例模式 public class New { private static New new1 = new New(); public static New getAccess(){ return new1; } public static void main(String[] args) { System."/>

    <meta property="og:title" content="Java笔记(持续更新)" />
<meta property="og:description" content="此笔记为本人在复习巩固Java基础时做的记录，内容很杂，持续更新中
this关键字 创建一个对象时分以下四部： 1.分配对象空间，将对象成员变量初始化为0或空 2.执行显示值的属性初始化 3.执行构造方法 4.返回对象的地址给相关变量 this 指的是“创建好的对象的地址”，在调用构造方法时，对象已被创建，在构造方法中使用this，代表“当前对象” this 用法 1. this.name = name; 避免程序二义 2. 使用this关键字调用重载的构造方法，避免初始化代码重复。 只能在构造方法中使用，只能引用一个，必须位于构造方法的第一句 （在构造器中，如果为this添加了参数列表，那么就有不同的含义。这将产生对符合此参数列表的某个构造器的明确调用） 3. this 不能用于static方法中（因为静态方法不依赖对象来进行访问，没有对象就谈不上this） 4. this 将当前对象本身作为参数传递给其他方法 5. return this; this 将当前对象作为参数返回，这样可以对一个对象进行多次操作  static关键字 当声明一个域或方法是static时，意味着这个域或方法不与包含他的那个类的任何对象关联在一起，与类相关联 方便在没有创建对象的情况下来进行调用（方法/变量） 1. static方法： 静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的 不需要对象便可通过类名进行调用（但是也可以通过对象进行调用） 2. static变量： 静态变量被所有对象共享，在内存中只有一个副本 3. static代码块： 优化程序性能（重复代码块） private static Date startDate,endDate; static{ startDate = Date.valueOf(&quot;1946&quot;); endDate = Date.valueOf(&quot;1964&quot;); } static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的 在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 构造器是static方法，它不需要对象来调用 static不会改变方法和变量的访问权限 静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够） 可用static来实现单例模式 public class New { private static New new1 = new New(); public static New getAccess(){ return new1; } public static void main(String[] args) { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sherry-long.github.io/post/blog/" />
<meta property="article:published_time" content="2021-01-26T12:38:16+08:00" />
<meta property="article:modified_time" content="2021-01-26T12:38:16+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://sherry-long.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>Sp(act)rum</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java笔记(持续更新)</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 26, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>此笔记为本人在复习巩固Java基础时做的记录，内容很杂，持续更新中</p>
<h3 id="this关键字">this关键字</h3>
<pre><code>创建一个对象时分以下四部：
    1.分配对象空间，将对象成员变量初始化为0或空
    2.执行显示值的属性初始化
    3.执行构造方法
    4.返回对象的地址给相关变量
	
this 指的是“创建好的对象的地址”，在调用构造方法时，对象已被创建，在构造方法中使用this，代表“当前对象”

this 用法
    1. this.name = name;
       避免程序二义
    2. 使用this关键字调用重载的构造方法，避免初始化代码重复。
       只能在构造方法中使用，只能引用一个，必须位于构造方法的第一句
       （在构造器中，如果为this添加了参数列表，那么就有不同的含义。这将产生对符合此参数列表的某个构造器的明确调用）
    3. this 不能用于static方法中（因为静态方法不依赖对象来进行访问，没有对象就谈不上this）
    4. this 将当前对象本身作为参数传递给其他方法
    5. return this;
       this 将当前对象作为参数返回，这样可以对一个对象进行多次操作
</code></pre>
<h3 id="static关键字">static关键字</h3>
<pre><code>当声明一个域或方法是static时，意味着这个域或方法不与包含他的那个类的任何对象关联在一起，与类相关联
方便在没有创建对象的情况下来进行调用（方法/变量）
    1. static方法：
        静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的
        不需要对象便可通过类名进行调用（但是也可以通过对象进行调用）
    2. static变量：
        静态变量被所有对象共享，在内存中只有一个副本
    3. static代码块：
        优化程序性能（重复代码块）
            private static Date startDate,endDate;
        static{
            startDate = Date.valueOf(&quot;1946&quot;);
            endDate = Date.valueOf(&quot;1964&quot;);
        }
        static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的
        在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。
    构造器是static方法，它不需要对象来调用
		
static不会改变方法和变量的访问权限
静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）

可用static来实现单例模式
    public class New {
        private static New new1 = new New();
        public static New getAccess(){
            return new1;
        }
        public static void main(String[] args) {
            System.out.println(New.getAccess());
            Object o = New.getAccess();
            System.out.println(o);
        }
    }
不论调用多少次getAccess(),返回的都是同一对象
</code></pre>
<h3 id="final关键字">final关键字</h3>
<pre><code>final关键字可用来修饰引用、方法和类
1.修饰引用
    1. 如果引用为基本数据类型，则该引用为常量，无法被修改
    2. 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址引用不能被修改
    3. 如果引用是类的成员变量，则必须当场赋值
2.修饰方法
    当用final修饰方法时，这个方法将成为最终方法，无法被子类重写，可被继承
3.修饰类
    当用final修饰类时，该类将成为最终类，无法被继承（断子绝孙类）
    （String就是最终类）
4.final参数
    参数列表中用final来修饰参数，在方法中无法对final修饰的对象进行修改
    此时参数只读
</code></pre>
<h3 id="范型">范型</h3>
<pre><code>一对尖括号&lt;&gt;
ArrayList&lt;Shape&gt; shapes = new.ArrayList&lt;Shape&gt;();
当将对象引用置入容器中时，它将向上转型为Object类，所以他会丢失当前身份。
取出时需要将对象引用向下转型，这依靠范型来实现
</code></pre>
<h3 id="序列化和反序列化">序列化和反序列化</h3>
<pre><code>序列化：将对象写入到IO流中
反序列化：从IO流中恢复对象
序列化机制允许将实现序列化的Java对象转换为字节序列，这些字节序列可以保存在磁盘上，
  或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序运行而独立存在

所有可在网络上传输的对象都必须是可序列化的，所有需要保存到磁盘上的对象都必须是可序列化的

反序列化不会调用构造方法，对象是由JVM自己生成的
 
所有保存到磁盘上的对象都有一个序列化编码
在程序试图序列化一个对象时，会先检查此对象是否已经被序列化过，如果已经序列化直接输出编号

对一个已经序列化的对象进行修改后，再次序列化则不会保存
transient（暂时）变量和static（静态）变量在序列化时会忽视

关于arraylist底层自定义序列化方法：
    arraylist底层采用数组实现，采用算法实现动态数组，数组通常不会被填满，直接调用序列化会序列化很多null对象，
      所以将elementData定义为transient防止直接序列化，重写序列化反序列化方法，循环遍历将元素序列化进流中
</code></pre>
<h3 id="可变参数">可变参数</h3>
<pre><code>类型 + ... + 形参名
定义时：
    f(Object... trailing);
调用时：
    f(&quot;one&quot;);
    f(&quot;one&quot;, &quot;two&quot;);
    f(1,2,3);
    f('a', 'b');
    f();
    都可以,会自动转型成object
</code></pre>
<h3 id="publicprotected和private">public、protected和private</h3>
<pre><code>public 所有人均可见
private 除本身外其他人不可访问
protected 对继承他的子类开放，有包内访问权限
</code></pre>
<h3 id="复用类">复用类</h3>
<pre><code>组合：

继承：使用通用类构造一个特例

代理：

重载：

覆写：
</code></pre>
<h3 id="多态">多态</h3>
<pre><code>多态通过分离“做什么”和“怎么做”，从另一角度将接口和实现分离开。
消除类型之间的耦合关系。

向上转型：
    在某些情况下，对象会自动向上转型成它的基类
    向一个参数为基类对象的方法中，传入一个子类，子类对象会自动向上转型，避免子类过多需要额外编写太多的代码
	
向下转型：
    编译器无法得知基类的继承类是哪个，引出“绑定”的概念
    绑定：将一个方法调用和一个方法主体关联起来称为绑定
    在运行时进行绑定，称为动态绑定或后期绑定
    Java中所有方法都是通过动态绑定来实现多态的
	
多态让程序员将改变的事物与未改变的事物分离开
多态意味着“不同的形式”，在面向对象程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式：不同版本的动态绑定
</code></pre>
<h3 id="抽象类接口">抽象类，接口</h3>
<pre><code>abstract关键字，如果一个类包含一个或多个抽象方法，该类就必须被限定为抽象的。
如果一个类继承抽象类，并想为该新类创建对象，就必须为抽象类中所有方法声明提供实现
abstract关键字允许人们在类中创建一个或多个没有任何定义的方法——提供了接口部分


接口：
    只有方法声明没有实现
  一个接口表示：所有实现了该特定接口的类看起来都这样
  任何使用特定接口的类都知道可以调用该接口的哪些方法，接口被用来建立类与类之间的协议。
  放入接口中的任何域都自动是static和final的
  实现一个接口时，不需要实现嵌套在它内部的任何接口，而且，private接口不能在定义它的类之外被实现
  接口是实现多重继承的途径
</code></pre>
<h3 id="java反射">java反射</h3>
<pre><code>写好的代码 -&gt; javac编译 -&gt; 字节码文件(.class) -&gt;     (源码阶段)
由类加载器(ClassLoader)加载进内存 -&gt; Class类对象(成员变量Field[] fields，构造方法Constructor[] constructors，成员方法Methods[] methods)用来描述.class字节码文件内容 -&gt;    (Class类对象阶段)
创建对象

反射：将类的各个组成部分封装为其他对象，这就是反射机制

好处：1.在程序的运行过程中操作这些对象，比如
                    String str = &quot;abc&quot;;
                    str.  (当键入.之后，编辑器会自动弹出下拉列表可选方法或属性，
                          这是因为类加载器已将String类加载进内存，
                          并将String的所有成员抽取出来存放到了Method[]数组中)
      2.解耦，降低程序耦合性，提高程序可扩展性
	  
获取class对象的方式：
    1.在源码阶段，class文件还未被加载进内存，需调用Class.forName(&quot;全类名&quot;)手动将class加载进内存，返回class对象
        * 多用于配置文件中，将类名定义在配置文件中，读取文件，加载类
    2.已经将字节码文件加载进内存，不需要加载可直接获取，通过类名获取  类名.class
        * 多用于参数传递
    3.已经创建了对象， 对象.class ,此方法已被封装在Object类中
        * 多用于对象的获取字节码的方式
同一个字节码文件再一次程序运行的过程中，只会被加载一次，无论通过哪一种方式获取的class对象都是同一个

使用class对象：
    大部分都是获取的功能
    1.获取成员变量
        getFields 获取所有public修饰的变量
        getDeclaredFields
        getField() 获取指定名字的成员变量
        使用set和get方法可以修改成员变量，但是对于private不可修改
        可以使用setAccessible(true)来忽略访问权限修饰符的安全检查，暴力反射
    2.获取构造方法
        ...
        ...
        创建对象 newInstance() 创建对应的对象
        如果构造使用空参数的构造方法创建对象，操作可以简化：可使用class对象的newInstance()方法
    3.获取成员方法
        ...
        ...
        getMethods() 不止获取你看到的方法，还会获取到Object的一些方法
		
        执行方法 invoke(对象, 参数);
        setAccessible()也可以使用
        获取方法名称 getName()
        使用invoke()方法可以执行方法
    4.获取类名等
        getName()
</code></pre>
<h3 id="jdk18-hashmap">JDK1.8 Hashmap</h3>
<pre><code>put()方法流程：
put(key, value) -&gt; 计算key的哈希值，计算方法：将key.hashCode()的低16位和高16位进行异或操作，减少碰撞 -&gt; 调用putVal -&gt; 先检查hashmap是否为空(是否初始化) -&gt; 
如未初始化，调用resize()方法进行初始化 -&gt; 找桶位，使用(n - 1) &amp; hash，根据哈希表规定，n必须为2的次幂，-1可得全1二进制，其计算结果=取余，计算机进行按位操作很快 -&gt;
找到桶位，如果桶位空，就new一个结点放入 -&gt; 如果桶位不为空，且该结点key等于插入key，将该节点保存到e中 -&gt; 如果该桶位已经树化，调用putVal的Tree版本，并保存到e -&gt;
如果头结点不是，链表循环检查，判断是否同key，以及是否到链尾，每次都将当前节点的下一节点保存到e中，找到同key就直接跳出循环，找不到则e成空 -&gt; 遍历到链尾没同key，插入结点 -&gt;
检查长度，超过8，树化 -&gt; 树化方法会检查哈希表长度，小于64则不树化(双重限制) -&gt; 最后检查e，不为空就检查标志位，选择是否更新value -&gt; 插入操作结束 -&gt;
检查容量是否到达阈值，如果到达就resize()扩容

resize()方法：
1.初始化
    如果旧table为空，对旧table进行初始化
2.扩容
    如果已达最长度，不进行扩容，如果 旧表长度 * 2 &lt; MAX_LENGTH &amp;&amp; 旧表长度 &gt;= 16 ，才进行扩容
</code></pre>
<h3 id="stringstringbuilderstringbuffer">String，StringBuilder，StringBuffer</h3>
<pre><code>String不可变字符序列，String内部并没有修改内容相应方法，每次修改String的方法其实质是创建一个新对象并将原引用指向它
StringBuilder 和 StringBuffer 都继承自 AbstractStringBuilder 父类，可变字符序列

StrngBuilder ：
    当构造一个有参StringBuilder时，会使用append方法，且初始化长度为 字符串长度 + 16 。此append方法是来自 AbstractStringBuilder
    append 是使用getChar实现的
    insert 方法也是来自父类，使用arraycopy实现
	
StringBuffer ：
    同上
    不同点：SBuf的方法有 synchronized 关键字修饰，对调用方法的对象加锁，线程安全，SBui的没有
	
StringBuilder 与 StringBuffer 区别：前者效率更高，后者线程安全
	
String常量 + ：String str1 = &quot;123&quot; + &quot;456&quot;; === String str1 = &quot;123456&quot;;
String变量 + ：String str1 = &quot;123&quot;, 
                      str2 = &quot;456&quot;, 
                      str3 = str1 + str2; === 先把str1转成SBuilder，使用append(str2)，再toString()转回来
</code></pre>
<h3 id="多线程">多线程</h3>
<pre><code>线程是进程的一个执行单元，一个线程就是进程中一个单一的控制流
进程是线程的容器，一个进程至少有一个线程，一个进程中也可以有多个线程

主线程和子线程
    JVM启动时会创建一个主线程，该主线程运行main方法
    Java中线程不是孤立的，线程之间存在一些联系。A线程创建了B线程，B是A的子线程，A是B的父线程
	
可以通过两种方法实现线程类：1）继承Thread类； 2）实现Runnable接口
1）
1.继承Thread类
2.重写run方法，run方法内部就是你的线程要做的事情
3.创建子线程对象
4.启动线程 thread.start()
    调用start()方法来启动线程，启动线程的实质就是请求JVM运行相应线程，这个线程具体在什么时候运行
    由线程调度器决定 Scheduler
    注意：
        start()方法调用结束并不代表子线程开始运行
        新开启的线程会执行run()方法
        如果开启了多个线程，start()调用的顺序并不一定就是线程启动的顺序
        多线程运行结果与代码执行顺序(调用顺序)无关

多线程运行结果有随机性
2）
当线程类已经有父类了，就不能继承Thread类了，
1.实现Runnable接口，重写run方法，run方法内部就是你的线程要做的事情
2.创建Runnable接口实现类对象 Myrunnable runnable = new Myrunnable();
3.创建线程对象 Thread thread = new Thread(runnable);
4.开启线程 thread.start();
第三步可以通过传递匿名内部类实现
	
线程常用方法：
    currentThread() 获得当前线程，Java中任何一段代码都是执行在某个线程当中的，执行当前代码的线程就是当前线程
</code></pre>
<h3 id="杂项">杂项</h3>
<pre><code> String s = new String(&quot;asdf&quot;);
 声明一个对象引用s，new：给我一个新对象
 
 Java对象创建在堆上，对象引用在堆栈上
 对象为什么不在堆上：创建程序时，Java系统必须知道存储在堆栈内的所有项的确切生命周期，以便上下移动堆栈指针（分配新内存以及回收内存）
                     在堆中存储时，编译器不需要知道存储的数据在堆中存活多久，更有灵活性，但是在堆中进行内存分配和清理比堆栈花时间更多
 对于基本类型，将他们存储在堆栈上不是很高效，new时，创建一个并非是引用的“自动“变量，这个变量直接存储值，并存储在堆栈上，更加高效。
 （基本类型，变量直接储存值）
 
 当创建一个数组对象时，对象会被自动初始化
</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
