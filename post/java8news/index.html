<!doctype html>
<html lang="en-us">
  <head>
    <title>Java8新特性 // Sp(act)rum</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="冯雪洋" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://sherry-long.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java8新特性"/>
<meta name="twitter:description" content="Lambda表达式 Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。 使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。
  作用：简化匿名内部类的代码写法
  本质：作为接口(内部只能有一个抽象方法 a.k.a 函数式接口)的实例
  public class lambda { @Test public void test(){ //常规写法  Comparator&lt;Integer&gt; com = new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1, o2); } }; int compare1 = com.compare(12, 21); System.out.println(compare1); //Lambda表达式写法  Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; Integer.compare(o1, o2); int compare2 = com1.compare(12, 21); System.out.println(compare2); /* exp : (o1, o2) -&gt; Integer."/>

    <meta property="og:title" content="Java8新特性" />
<meta property="og:description" content="Lambda表达式 Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。 使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。
  作用：简化匿名内部类的代码写法
  本质：作为接口(内部只能有一个抽象方法 a.k.a 函数式接口)的实例
  public class lambda { @Test public void test(){ //常规写法  Comparator&lt;Integer&gt; com = new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return Integer.compare(o1, o2); } }; int compare1 = com.compare(12, 21); System.out.println(compare1); //Lambda表达式写法  Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; Integer.compare(o1, o2); int compare2 = com1.compare(12, 21); System.out.println(compare2); /* exp : (o1, o2) -&gt; Integer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sherry-long.github.io/post/java8news/" />
<meta property="article:published_time" content="2022-10-08T19:36:49+08:00" />
<meta property="article:modified_time" content="2022-10-08T19:36:49+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://sherry-long.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="冯雪洋" /></a>
      <h1>Sp(act)rum</h1>
      <p>这个人很懒，什么介绍都没留下</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/Sherry-long" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://space.bilibili.com/13547597" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java8新特性</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Oct 8, 2022
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h3 id="lambda表达式">Lambda表达式</h3>
<p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码(将代码像数据一样进行传递)。
使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<ul>
<li>
<p>作用：简化匿名内部类的代码写法</p>
</li>
<li>
<p>本质：作为接口(内部只能有一个抽象方法 a.k.a 函数式接口)的实例</p>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">lambda</span> <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Test</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(){</span>
        <span style="color:#75715e">//常规写法
</span><span style="color:#75715e"></span>        Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> com <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>Integer o1<span style="color:#f92672">,</span> Integer o2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>o1<span style="color:#f92672">,</span> o2<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">};</span>
        <span style="color:#66d9ef">int</span> compare1 <span style="color:#f92672">=</span> com<span style="color:#f92672">.</span><span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>12<span style="color:#f92672">,</span> 21<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>compare1<span style="color:#f92672">);</span>
        <span style="color:#75715e">//Lambda表达式写法
</span><span style="color:#75715e"></span>        Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> com1 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>o1<span style="color:#f92672">,</span> o2<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>o1<span style="color:#f92672">,</span> o2<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> compare2 <span style="color:#f92672">=</span> com1<span style="color:#f92672">.</span><span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>12<span style="color:#f92672">,</span> 21<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>compare2<span style="color:#f92672">);</span>
        <span style="color:#75715e">/*
</span><span style="color:#75715e">        exp : (o1, o2) -&gt; Integer.compare(o1, o2);
</span><span style="color:#75715e">        -&gt; : lambda操作符 或 箭头操作符
</span><span style="color:#75715e">        -&gt;左边 : 指定了lambda表达式需要的形参列表
</span><span style="color:#75715e">                不需要指明类型（类型推断）
</span><span style="color:#75715e">                当左侧只有一个参数时，括号可以省略
</span><span style="color:#75715e">        -&gt;右边 : 指定了lambda体，抽象方法的实现逻辑
</span><span style="color:#75715e">                当lambda体中只有一条语句时，return 与 大括号(若有) 可省略(见exp)
</span><span style="color:#75715e">         */</span>
        <span style="color:#75715e">//方法引用写法
</span><span style="color:#75715e"></span>        Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> com2 <span style="color:#f92672">=</span> Integer<span style="color:#f92672">::</span>compare<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> compare3 <span style="color:#f92672">=</span> com2<span style="color:#f92672">.</span><span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>12<span style="color:#f92672">,</span> 21<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>compare3<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

<span style="color:#f92672">}</span>
</code></pre></div><hr>
<hr>
<h3 id="函数式functional接口">函数式(Functional)接口</h3>
<p>如果一个接口中只声明了一个抽象方法，就称此接口为函数式接口，
可为函数式接口添加 @FunctionalInterface 接口，以便编译器帮助检查</p>
<ul>
<li>
<p>可以通过Lambda表达式来创建该接口的对象。(若Lambda表达式抛出一个受检异常，即非运行时异常，那么该异常需要在目标接口的抽象方法上进行声明)</p>
</li>
<li>
<p>在java.util.function包下定义了Java 8的丰富的函数式接口</p>
</li>
</ul>
<h4 id="java内置四大核心函数式接口">Java内置四大核心函数式接口</h4>
<ul>
<li>Consumer<!-- raw HTML omitted --> 消费性接口</li>
</ul>
<pre><code>参数类型：T
返回类型：void
用途：对类型为T的对象应用操作，包含方法：void accept(T t)
</code></pre><ul>
<li>Supplier<!-- raw HTML omitted --> 供给型接口</li>
</ul>
<pre><code>参数类型：无
返回类型：T
用途：返回类型为T的对象，包含方法：T get()
</code></pre><ul>
<li>Function&lt;T, R&gt; 函数型接口</li>
</ul>
<pre><code>参数类型：T
返回类型：R
用途：对类型为T的对象应用操作，并返回结果(类型R)。包含方法：R apply(T t)
</code></pre><ul>
<li>Predicate<!-- raw HTML omitted --> 断定型接口</li>
</ul>
<pre><code>参数类型：T
返回类型：boolean
用途：确定类型为T的对象是否满足某约束，并返回boolean。boolean test(T t)
</code></pre><h4 id="其他接口">其他接口</h4>
<ul>
<li>BiFunctional&lt;T, U, R&gt;</li>
</ul>
<pre><code>参数类型：T，U
返回值类型：R
用途：对类型T，U参数应用操作，返回R类型结果 R apply(T t, U u)
</code></pre><ul>
<li>UnaryOperator<!-- raw HTML omitted --></li>
</ul>
<pre><code>参数类型：T
返回值类型：T
用途：对类型为T的对象进行一元运算，并返回T类型的结果 T apply(T t)
</code></pre><ul>
<li>BinaryOperator<!-- raw HTML omitted --></li>
</ul>
<pre><code>参数类型：T，T
返回值类型：T
用途：对类型为T的对象进行二元运算，并返回T类型的结果 T apply(T t1, T t2)
</code></pre><ul>
<li>BiConsumer&lt;T, U&gt;</li>
</ul>
<pre><code>参数类型：T，U
返回值类型：void
用途：void accept(T t, U u)
</code></pre><ul>
<li>BiPredicate&lt;T, U&gt;</li>
</ul>
<pre><code>参数类型：T，U
返回值类型：boolean
用途：boolean test(T t, U u)
</code></pre><ul>
<li>ToInt(Long, Double)Function<!-- raw HTML omitted --></li>
</ul>
<pre><code>参数类型：T
返回值类型：int(long, double)
用途：分别计算int、long、double值的函数
</code></pre><ul>
<li>Int(Long, Double)Function<!-- raw HTML omitted --></li>
</ul>
<pre><code>参数类型：int(long, double)
返回值类型：R
用途：参数分别为int、long、double类型的函数
</code></pre><hr>
<hr>
<h3 id="方法引用与构造器引用">方法引用与构造器引用</h3>
<p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</p>
<p>方法引用可以看作是Lambda表达式的深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的另一个实例。</p>
<ul>
<li>
<p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</p>
</li>
<li>
<p>格式：使用 :: 将类(或对象)与方法名分割开来</p>
</li>
</ul>
<pre><code>如下三种主要使用情况：
对象::实例方法名
类::静态方法名
类::实例方法名
</code></pre><p>构造器引用：与方法引用类似</p>
<hr>
<hr>
<h3 id="stream-api">Stream API</h3>
<p>Stream API(java.util.stram)把真正的函数式编程风格引入Java中。这是目前为止对Java类库最好的补充，
因为Stream API可以极大提高Java程序员生产力。</p>
<p>Stream是Java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。</p>
<ul>
<li>使用Stream API对集合数据进行操作，就类似于使用SQL执行的数据库查询</li>
</ul>
<p>也可以使用Stream API来并行执行操作。简言之，Stream API提供了一种高效且易于使用的处理数据的方式</p>
<h4 id="为什么要使用stream-api">为什么要使用Stream API</h4>
<ul>
<li>
<p>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有些NoSQL数据需要Java层面处理</p>
</li>
<li>
<p>Stream和Collecion集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的。前者是面向内存，存储在内存中。后者主要是面向CPU，通过CPU实现计算</p>
</li>
</ul>
<h4 id="什么是stream">什么是Stream</h4>
<p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列
“集合讲的是数据，Stream讲的是计算”</p>
<pre><code>1.Stream自己不会存储元素
2.Stream不会改变源对象，他们会返回一个持有结果的新Stream（不可变）
3.Stream操作是延迟执行的。他们可能会等到需要结果的时候才执行
</code></pre><h4 id="stream操作的三个步骤">Stream操作的三个步骤</h4>
<ul>
<li>
<p>创建Stream
一个数据源（如：集合、数组），获取一个流</p>
</li>
<li>
<p>中间操作
一个中间操作链，对数据源的数据进行处理</p>
</li>
<li>
<p>终止操作(终端操作)
一旦执行终止操作，就执行中间操作链，并产生结果。之后不会再被使用</p>
</li>
</ul>
<h3 id="创建stream的方式">创建Stream的方式</h3>
<ul>
<li>一 通过集合
Java8中的Collection接口被扩展，提供了两个获取流的方法：</li>
</ul>
<pre><code>default Stream&lt;E&gt; stream() : 返回一个顺序流
default Stream&lt;E&gt; parallelStream() : 返回一个并行流
</code></pre><ul>
<li>二 通过数组
Java8中的Arrays的静态方法stream()可以获取数组流：</li>
</ul>
<pre><code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) : 返回一个流

重载形式：
public static IntStream stream(int[] array)
public static LongStream stream(long[] array)
public static DoubleStream stream(double[] array)
</code></pre><ul>
<li>三 通过Stream的of()
可以调用Stream类静态方法of()，通过显示值创建一个流。他可以接受任意数量的参数</li>
</ul>
<pre><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流
</code></pre><ul>
<li>四 创建无限流
可以使用静态方法Stream.iterate()和Stream.generate()，创建无限流</li>
</ul>
<pre><code>迭代
public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)
生成
public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)
</code></pre><hr>
<hr>
<h3 id="optional类">Optional类</h3>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
