<!doctype html>
<html lang="en-us">
  <head>
    <title>Redis基础 // Sp(act)rum</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="冯雪洋" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://sherry-long.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis基础"/>
<meta name="twitter:description" content="一、Redis入门 1.认识NoSQL 1.1	什么是NoSQL   NoSQL最常见的解释是&quot;non-relational&quot;， 很多人也说它是&quot;Not Only SQL&quot; NoSQL仅仅是一个概念，泛指非关系型的数据库 区别于关系数据库，它们不保证关系数据的ACID特性 NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入 常见的NoSQL数据库有：Redis、MemCache、MongoDB等  1.2	NoSQL与SQL的差异      SQL NoSQL     数据结构 结构化 非结构化   数据关联 关联的 无关联的   查询方式 SQL查询 非SQL   事务特性 ACID BASE   存储方式 磁盘 内存   扩展性 垂直 水平   使用场景 1）数据结构固定
2）相关业务对数据安全性、一致性要求较高 1）数据结构不固定
2）对一致性、安全性要求不高
3）对性能要求    2.认识Redis  Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。"/>

    <meta property="og:title" content="Redis基础" />
<meta property="og:description" content="一、Redis入门 1.认识NoSQL 1.1	什么是NoSQL   NoSQL最常见的解释是&quot;non-relational&quot;， 很多人也说它是&quot;Not Only SQL&quot; NoSQL仅仅是一个概念，泛指非关系型的数据库 区别于关系数据库，它们不保证关系数据的ACID特性 NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入 常见的NoSQL数据库有：Redis、MemCache、MongoDB等  1.2	NoSQL与SQL的差异      SQL NoSQL     数据结构 结构化 非结构化   数据关联 关联的 无关联的   查询方式 SQL查询 非SQL   事务特性 ACID BASE   存储方式 磁盘 内存   扩展性 垂直 水平   使用场景 1）数据结构固定
2）相关业务对数据安全性、一致性要求较高 1）数据结构不固定
2）对一致性、安全性要求不高
3）对性能要求    2.认识Redis  Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sherry-long.github.io/post/redis/" />
<meta property="article:published_time" content="2022-12-04T17:13:26+08:00" />
<meta property="article:modified_time" content="2022-12-04T17:13:26+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://sherry-long.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="冯雪洋" /></a>
      <h1>Sp(act)rum</h1>
      <p>这个人很懒，什么介绍都没留下</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/Sherry-long" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://space.bilibili.com/13547597" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Redis基础</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Dec 4, 2022
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          5 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="一redis入门">一、Redis入门</h1>
<h2 id="1认识nosql">1.认识NoSQL</h2>
<h3 id="11什么是nosql">1.1	什么是NoSQL</h3>
<hr>
<ul>
<li>NoSQL最常见的解释是&quot;<code>non-relational</code>&quot;， 很多人也说它是&quot;<em><strong>Not Only SQL</strong></em>&quot;</li>
<li>NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong></li>
<li>区别于关系数据库，它们不保证关系数据的ACID特性</li>
<li>NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</li>
<li>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</li>
</ul>
<h3 id="12nosql与sql的差异">1.2	NoSQL与SQL的差异</h3>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">SQL</th>
<th style="text-align:center">NoSQL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据结构</td>
<td style="text-align:center">结构化</td>
<td style="text-align:center">非结构化</td>
</tr>
<tr>
<td style="text-align:center">数据关联</td>
<td style="text-align:center">关联的</td>
<td style="text-align:center">无关联的</td>
</tr>
<tr>
<td style="text-align:center">查询方式</td>
<td style="text-align:center">SQL查询</td>
<td style="text-align:center">非SQL</td>
</tr>
<tr>
<td style="text-align:center">事务特性</td>
<td style="text-align:center">ACID</td>
<td style="text-align:center">BASE</td>
</tr>
<tr>
<td style="text-align:center">存储方式</td>
<td style="text-align:center">磁盘</td>
<td style="text-align:center">内存</td>
</tr>
<tr>
<td style="text-align:center">扩展性</td>
<td style="text-align:center">垂直</td>
<td style="text-align:center">水平</td>
</tr>
<tr>
<td style="text-align:center">使用场景</td>
<td style="text-align:center">1）数据结构固定<br>2）相关业务对数据安全性、一致性要求较高</td>
<td style="text-align:center">1）数据结构不固定<br>2）对一致性、安全性要求不高<br>3）对性能要求</td>
</tr>
</tbody>
</table>
<h2 id="2认识redis">2.认识Redis</h2>
<blockquote>
<p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>
</blockquote>
<p><strong>Redis的特征：</strong></p>
<ul>
<li>键值（<code>key-value</code>）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
<li>支持多语言客户端</li>
</ul>
<h2 id="3安装redis">3.安装Redis</h2>
<h3 id="31前置准备">3.1	前置准备</h3>
<hr>
<blockquote>
<p>本次安装Redis是基于Linux系统下安装的，因此需要一台Linux服务器或者虚拟机。</p>
<p>Ps：由于提供的CentOS操作系统为mini版，因此需要自行配置网络，不会配置的请联系我，如果您使用的是自己购买的服务器，请提前开放<code>6379</code>端口，避免后续出现的莫名其妙的错误！</p>
</blockquote>
<ul>
<li>
<p><strong>虚拟机</strong>：<a href="https://pan.baidu.com/s/1Zn13h9G7MtSgz-xdkQFeJg?pwd=1234">VMware16</a></p>
</li>
<li>
<p><strong>操作系统</strong>：<a href="https://pan.baidu.com/s/1SiYip29cYqiNBqjGGV0JgA?pwd=1234">CentOS-7-x86_64-Minimal-1708</a></p>
</li>
<li>
<p><strong>Redis</strong>：<a href="https://pan.baidu.com/s/1hsoEz1NTCDCCWZmaiZrIgg?pwd=1234">redis-6.2.6.tar</a></p>
</li>
<li>
<p><strong>xShell及xFtp</strong>：https://www.xshell.com/zh/free-for-home-school/</p>
</li>
</ul>
<h3 id="32安装redis依赖">3.2	安装Redis依赖</h3>
<hr>
<blockquote>
<p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">yum install -y gcc tcl
</code></pre></div><p><strong>安装成功如下图所示：</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524181842626.png" alt="image-20220524181842626"></p>
<h3 id="33正式安装redis">3.3	正式安装Redis</h3>
<hr>
<ul>
<li>
<p><strong>将<code>redis-6.2.6.tar</code>上传至<code>/usr/local/src</code>目录</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524185659727.png" alt="image-20220524185659727"></p>
</li>
<li>
<p><strong>在xShell中<code>cd</code>到<code>/usr/local/src</code>目录执行以下命令进行解压操作</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">tar -xzf redis-6.2.6.tar.gz
</code></pre></div></li>
<li>
<p><strong>解压成功后依次执行以下命令</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">cd redis-6.2.6
make
make install
</code></pre></div></li>
<li>
<p><strong>安装成功后打开/usr/local/bin目录（该目录为Redis默认的安装目录）</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524190400547.png" alt="image-20220524190400547"></p>
</li>
</ul>
<h2 id="4启动redis">4.启动Redis</h2>
<blockquote>
<p>Redis的启动方式有很多种，例如：<strong>前台启动</strong>、<strong>后台启动</strong>、<strong>开机自启</strong></p>
</blockquote>
<h3 id="41前台启动不推荐">4.1	前台启动（不推荐）</h3>
<hr>
<blockquote>
<p><strong>这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</strong></p>
</blockquote>
<ul>
<li>
<p><strong>安装完成后，在任意目录输入<code>redis-server</code>命令即可启动Redis</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">redis-server
</code></pre></div></li>
<li>
<p><strong>启动成功如下图所示</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524191137983.png" alt="image-20220524191137983"></p>
</li>
</ul>
<h3 id="42后台启动不推荐">4.2	后台启动（不推荐）</h3>
<hr>
<blockquote>
<p><strong>如果要让Redis以后台方式启动，则必须修改Redis配置文件，配置文件所在目录就是之前我们解压的安装包下</strong></p>
</blockquote>
<ul>
<li>
<p><strong>因为我们要修改配置文件，因此我们需要先将原文件备份一份</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">cd /usr/local/src/redis-6.2.6
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">cp redis.conf redis.conf.bck
</code></pre></div></li>
<li>
<p><strong>然后修改<code>redis.conf</code>文件中的一些配置</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span>
bind 0.0.0.0
<span style="color:#75715e"># 守护进程，修改为yes后即可后台运行</span>
daemonize yes 
<span style="color:#75715e"># 密码，设置后访问Redis必须输入密码</span>
requirepass <span style="color:#ae81ff">1325</span>
</code></pre></div></li>
<li>
<p><strong>Redis其他常用配置</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 监听的端口</span>
port <span style="color:#ae81ff">6379</span>
<span style="color:#75715e"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span>
dir .
<span style="color:#75715e"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span>
databases <span style="color:#ae81ff">1</span>
<span style="color:#75715e"># 设置redis能够使用的最大内存</span>
maxmemory 512mb
<span style="color:#75715e"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span>
logfile <span style="color:#e6db74">&#34;redis.log&#34;</span>
</code></pre></div></li>
<li>
<p><strong>启动Redis</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 进入redis安装目录 </span>
cd /usr/local/src/redis-6.2.6
<span style="color:#75715e"># 启动</span>
redis-server redis.conf
</code></pre></div></li>
<li>
<p><strong>停止Redis服务</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 通过kill命令直接杀死进程</span>
kill -9 redis进程id
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span>
<span style="color:#75715e"># 因为之前配置了密码，因此需要通过 -a 来指定密码</span>
redis-cli -a <span style="color:#ae81ff">132537</span> shutdown
</code></pre></div></li>
</ul>
<h3 id="43开机自启推荐">4.3	开机自启（推荐）</h3>
<hr>
<blockquote>
<p><strong>我们也可以通过配置来实现开机自启</strong></p>
</blockquote>
<ul>
<li>
<p><strong>首先，新建一个系统服务文件</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">vi /etc/systemd/system/redis.service
</code></pre></div></li>
<li>
<p><strong>将以下命令粘贴进去</strong></p>
<pre><code class="language-conf" data-lang="conf">[Unit]
Description=redis-server
After=network.target
  
[Service]
Type=forking
ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf
PrivateTmp=true
  
[Install]
WantedBy=multi-user.target
</code></pre></li>
<li>
<p><strong>然后重载系统服务</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">systemctl daemon-reload
</code></pre></div></li>
<li>
<p><strong>现在，我们可以用下面这组命令来操作redis了</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># 启动</span>
systemctl start redis
<span style="color:#75715e"># 停止</span>
systemctl stop redis
<span style="color:#75715e"># 重启</span>
systemctl restart redis
<span style="color:#75715e"># 查看状态</span>
systemctl status redis
</code></pre></div></li>
<li>
<p><strong>执行下面的命令，可以让redis开机自启</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">systemctl enable redis
</code></pre></div></li>
</ul>
<h1 id="二redis常见命令">二、Redis常见命令</h1>
<blockquote>
<p>我们可以通过Redis的中文文档：http://www.redis.cn/commands.html，来学习各种命令。</p>
<p>也可以通过菜鸟教程官网来学习：https://www.runoob.com/redis/redis-keys.html</p>
</blockquote>
<h2 id="1redis数据结构介绍">1.Redis数据结构介绍</h2>
<blockquote>
<p><strong>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524205926164.png" alt="image-20220524205926164"></p>
<h2 id="2通用命令">2.通用命令</h2>
<blockquote>
<p><strong>通用指令是部分数据类型的，都可以使用的指令，常见的有如下表格所示</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">KEYS</td>
<td style="text-align:center">查看符合模板的所有key，不建议在生产环境设备上使用</td>
</tr>
<tr>
<td style="text-align:center">DEL</td>
<td style="text-align:center">删除一个指定的key</td>
</tr>
<tr>
<td style="text-align:center">EXISTS</td>
<td style="text-align:center">判断key是否存在</td>
</tr>
<tr>
<td style="text-align:center">EXPIRE</td>
<td style="text-align:center">给一个key设置有效期，有效期到期时该key会被自动删除，单位为秒</td>
</tr>
<tr>
<td style="text-align:center">TTL</td>
<td style="text-align:center">查看一个KEY的剩余有效期，单位为秒</td>
</tr>
</tbody>
</table>
<p><strong>可以通过<code>help [command] </code>可以查看一个命令的具体用法！</strong></p>
<h2 id="3string类型">3.String类型</h2>
<blockquote>
<p><strong>String类型，也就是字符串类型，是Redis中最简单的存储类型。</strong></p>
</blockquote>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li><code>string</code>：普通字符串</li>
<li><code>int</code>：整数类型，可以做自增、自减操作</li>
<li><code>float</code>：浮点类型，可以做自增、自减操作</li>
</ul>
<blockquote>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过<strong>512m</strong>.</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">KEY</th>
<th style="text-align:center">VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">msg</td>
<td style="text-align:center">hello world</td>
</tr>
<tr>
<td style="text-align:center">num</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">score</td>
<td style="text-align:center">92.5</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>String的常见命令有如下表格所示</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SET</td>
<td style="text-align:center">添加或者修改已经存在的一个String类型的键值对</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">根据key获取String类型的value</td>
</tr>
<tr>
<td style="text-align:center">MSET</td>
<td style="text-align:center">批量添加多个String类型的键值对</td>
</tr>
<tr>
<td style="text-align:center">MGET</td>
<td style="text-align:center">根据多个key获取多个String类型的value</td>
</tr>
<tr>
<td style="text-align:center">INCR</td>
<td style="text-align:center">让一个整型的key自增1</td>
</tr>
<tr>
<td style="text-align:center">INCRBY</td>
<td style="text-align:center">让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td>
</tr>
<tr>
<td style="text-align:center">INCRBYFLOAT</td>
<td style="text-align:center">让一个浮点类型的数字自增并指定步长</td>
</tr>
<tr>
<td style="text-align:center">SETNX</td>
<td style="text-align:center">添加一个String类型的键值对，前提是这个key不存在，否则不执行</td>
</tr>
<tr>
<td style="text-align:center"><strong>SETEX</strong></td>
<td style="text-align:center">添加一个String类型的键值对，并且指定有效期</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：</strong></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-tex" data-lang="tex">项目名:业务名:类型:id
</code></pre></div><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。</p>
<p>例如我们的项目名称叫 <code>heima</code>，有<code>user</code>和<code>product</code>两种不同类型的数据，我们可以这样定义key：</p>
<ul>
<li><strong>user</strong>相关的key：<code>heima:user:1</code></li>
<li><strong>product</strong>相关的key：<code>heima:product:1</code></li>
</ul>
<p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p>
<table>
<thead>
<tr>
<th style="text-align:center">KEY</th>
<th style="text-align:center">VALUE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">heima:user:1</td>
<td style="text-align:center">{&ldquo;id&rdquo;:1, &ldquo;name&rdquo;: &ldquo;Jack&rdquo;, &ldquo;age&rdquo;: 21}</td>
</tr>
<tr>
<td style="text-align:center">heima:product:1</td>
<td style="text-align:center">{&ldquo;id&rdquo;:1, &ldquo;name&rdquo;: &ldquo;小米11&rdquo;, &ldquo;price&rdquo;: 4999}</td>
</tr>
</tbody>
</table>
<h2 id="4hash类型">4.Hash类型</h2>
<blockquote>
<p><strong>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的<code>HashMap</code>结构。</strong></p>
</blockquote>
<ul>
<li>
<p><strong>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525001227167.png" alt="image-20220525001227167"  /></p>
</li>
<li>
<p><strong>Hash的常见命令有：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HSET key field value</td>
<td style="text-align:center">添加或者修改hash类型key的field的值</td>
</tr>
<tr>
<td style="text-align:center">HGET key field</td>
<td style="text-align:center">获取一个hash类型key的field的值</td>
</tr>
<tr>
<td style="text-align:center">HMSET</td>
<td style="text-align:center">hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td>
</tr>
<tr>
<td style="text-align:center">HMGET</td>
<td style="text-align:center">批量获取多个hash类型key的field的值</td>
</tr>
<tr>
<td style="text-align:center">HGETALL</td>
<td style="text-align:center">获取一个hash类型的key中的所有的field和value</td>
</tr>
<tr>
<td style="text-align:center">HKEYS</td>
<td style="text-align:center">获取一个hash类型的key中的所有的field</td>
</tr>
<tr>
<td style="text-align:center">HVALS</td>
<td style="text-align:center">获取一个hash类型的key中的所有的value</td>
</tr>
<tr>
<td style="text-align:center">HINCRBY</td>
<td style="text-align:center">让一个hash类型key的字段值自增并指定步长</td>
</tr>
<tr>
<td style="text-align:center">HSETNX</td>
<td style="text-align:center">添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="5list类型">5.List类型</h2>
<blockquote>
<p><strong>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</strong></p>
</blockquote>
<p><strong>特征也与<code>LinkedList</code>类似：</strong></p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等.</p>
<blockquote>
<p><strong>List的常见命令有</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LPUSH key  element &hellip;</td>
<td style="text-align:center">向列表左侧插入一个或多个元素</td>
</tr>
<tr>
<td style="text-align:center">LPOP key</td>
<td style="text-align:center">移除并返回列表左侧的第一个元素，没有则返回nil</td>
</tr>
<tr>
<td style="text-align:center"><strong>RPUSH key  element &hellip;</strong></td>
<td style="text-align:center">向列表右侧插入一个或多个元素</td>
</tr>
<tr>
<td style="text-align:center">RPOP key</td>
<td style="text-align:center">移除并返回列表右侧的第一个元素</td>
</tr>
<tr>
<td style="text-align:center">LRANGE key star end</td>
<td style="text-align:center">返回一段角标范围内的所有元素</td>
</tr>
<tr>
<td style="text-align:center">BLPOP和BRPOP</td>
<td style="text-align:center">与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td>
</tr>
</tbody>
</table>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/new.gif" alt="new"></p>
<blockquote>
<p><strong>思考问题</strong></p>
</blockquote>
<ul>
<li>
<p><strong>如何利用List结构模拟一个栈?</strong></p>
<ul>
<li>先进后出，入口和出口在同一边</li>
</ul>
</li>
<li>
<p><strong>如何利用List结构模拟一个队列?</strong></p>
<ul>
<li>先进先出，入口和出口在不同边</li>
</ul>
</li>
<li>
<p><strong>如何利用List结构模拟一个阻塞队列?</strong></p>
<ul>
<li>入口和出口在不同边</li>
<li>出队时采用BLPOP或BRPOP</li>
</ul>
</li>
</ul>
<h2 id="6set类型">6.Set类型</h2>
<blockquote>
<p><strong>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征</strong></p>
</blockquote>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<blockquote>
<p><strong>Set的常见命令有</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SADD key member &hellip;</td>
<td style="text-align:center">向set中添加一个或多个元素</td>
</tr>
<tr>
<td style="text-align:center">SREM key member &hellip;</td>
<td style="text-align:center">移除set中的指定元素</td>
</tr>
<tr>
<td style="text-align:center">SCARD key</td>
<td style="text-align:center">返回set中元素的个数</td>
</tr>
<tr>
<td style="text-align:center">SISMEMBER key member</td>
<td style="text-align:center">判断一个元素是否存在于set中</td>
</tr>
<tr>
<td style="text-align:center">SMEMBERS</td>
<td style="text-align:center">获取set中的所有元素</td>
</tr>
<tr>
<td style="text-align:center">SINTER key1 key2 &hellip;</td>
<td style="text-align:center">求key1与key2的交集</td>
</tr>
<tr>
<td style="text-align:center">SDIFF key1 key2 &hellip;</td>
<td style="text-align:center">求key1与key2的差集</td>
</tr>
<tr>
<td style="text-align:center">SUNION key1 key2 ..</td>
<td style="text-align:center">求key1和key2的并集</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>交集、差集、并集图示</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525112632214.png" alt="image-20220525112632214"></p>
<h2 id="7sortedset类型">7.SortedSet类型</h2>
<blockquote>
<p><strong>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</strong></p>
</blockquote>
<p><strong>SortedSet具备下列特性：</strong></p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<blockquote>
<p><strong>SortedSet的常见命令有</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ZADD key score member</td>
<td style="text-align:center">添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td>
</tr>
<tr>
<td style="text-align:center">ZREM key member</td>
<td style="text-align:center">删除sorted set中的一个指定元素</td>
</tr>
<tr>
<td style="text-align:center">ZSCORE key member</td>
<td style="text-align:center">获取sorted set中的指定元素的score值</td>
</tr>
<tr>
<td style="text-align:center">ZRANK key member</td>
<td style="text-align:center">获取sorted set 中的指定元素的排名</td>
</tr>
<tr>
<td style="text-align:center">ZCARD key</td>
<td style="text-align:center">获取sorted set中的元素个数</td>
</tr>
<tr>
<td style="text-align:center">ZCOUNT key min max</td>
<td style="text-align:center">统计score值在给定范围内的所有元素的个数</td>
</tr>
<tr>
<td style="text-align:center">ZINCRBY key increment member</td>
<td style="text-align:center">让sorted set中的指定元素自增，步长为指定的increment值</td>
</tr>
<tr>
<td style="text-align:center">ZRANGE key min max</td>
<td style="text-align:center">按照score排序后，获取指定排名范围内的元素</td>
</tr>
<tr>
<td style="text-align:center">ZRANGEBYSCORE key min max</td>
<td style="text-align:center">按照score排序后，获取指定score范围内的元素</td>
</tr>
<tr>
<td style="text-align:center">ZDIFF、ZINTER、ZUNION</td>
<td style="text-align:center">求差集、交集、并集</td>
</tr>
</tbody>
</table>
<p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加<code>REV</code>即可</strong></p>
<h1 id="三redis客户端">三、Redis客户端</h1>
<blockquote>
<p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p>
</blockquote>
<ul>
<li><strong>命令行客户端</strong></li>
<li><strong>图形化桌面客户端</strong></li>
<li><strong>编程客户端</strong></li>
</ul>
<h2 id="1命令行客户端">1.命令行客户端</h2>
<ul>
<li>
<p><strong>Redis安装完成后就自带了命令行客户端：<code>redis-cli</code>，使用方式如下：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">redis-cli <span style="color:#f92672">[</span>options<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>commonds<span style="color:#f92672">]</span>
</code></pre></div></li>
<li>
<p><strong>其中常见的<code>options</code>有：</strong></p>
<ul>
<li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li>
<li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li>
<li><code>-a 132537</code>：指定redis的访问密码</li>
</ul>
</li>
<li>
<p><strong>其中的<code>commonds</code>就是Redis的操作命令，例如：</strong></p>
<ul>
<li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li>
<li>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</li>
</ul>
</li>
</ul>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524201258092.png" alt="image-20220524201258092"></p>
<h2 id="2图形化客户端">2.图形化客户端</h2>
<blockquote>
<p>下载地址：https://pan.baidu.com/s/1sxQTOt-A5MCvVZnlgDf0eA?pwd=1234</p>
</blockquote>
<ul>
<li>
<p><strong>安装图形化客户端</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-tex" data-lang="tex">安装步骤过于简单不再演示
</code></pre></div></li>
<li>
<p><strong>如何连接到Redis</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524202853286.png" alt="image-20220524202853286" style="zoom:80%;" /></p>
</li>
<li>
<p><strong>连接成功后如图所示</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220524203745436.png" alt="image-20220524203745436" style="zoom:80%;" /></p>
</li>
</ul>
<h2 id="3java客户端">3.Java客户端</h2>
<h3 id="31jedis快速入门">3.1	Jedis快速入门</h3>
<hr>
<blockquote>
<p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a>，我们先来个快速入门：</p>
</blockquote>
<ul>
<li>
<p><strong>新建一个Maven工程并引入以下依赖</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;!--引入Jedis依赖--&gt;</span>
<span style="color:#f92672">&lt;dependency&gt;</span>
    <span style="color:#f92672">&lt;groupId&gt;</span>redis.clients<span style="color:#f92672">&lt;/groupId&gt;</span>
    <span style="color:#f92672">&lt;artifactId&gt;</span>jedis<span style="color:#f92672">&lt;/artifactId&gt;</span>
    <span style="color:#f92672">&lt;version&gt;</span>4.2.0<span style="color:#f92672">&lt;/version&gt;</span>
<span style="color:#f92672">&lt;/dependency&gt;</span>
  
<span style="color:#75715e">&lt;!--引入单元测试依赖--&gt;</span>
<span style="color:#f92672">&lt;dependency&gt;</span>
    <span style="color:#f92672">&lt;groupId&gt;</span>org.junit.jupiter<span style="color:#f92672">&lt;/groupId&gt;</span>
    <span style="color:#f92672">&lt;artifactId&gt;</span>junit-jupiter<span style="color:#f92672">&lt;/artifactId&gt;</span>
    <span style="color:#f92672">&lt;version&gt;</span>5.8.2<span style="color:#f92672">&lt;/version&gt;</span>
    <span style="color:#f92672">&lt;scope&gt;</span>test<span style="color:#f92672">&lt;/scope&gt;</span>
<span style="color:#f92672">&lt;/dependency&gt;</span>
</code></pre></div></li>
<li>
<p><strong>编写测试类并与Redis建立连接</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> Jedis jedis<span style="color:#f92672">;</span>
  
<span style="color:#a6e22e">@BeforeEach</span> <span style="color:#75715e">//被该注解修饰的方法每次执行其他方法前自动执行
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setUp</span><span style="color:#f92672">(){</span>
    <span style="color:#75715e">// 1. 获取连接
</span><span style="color:#75715e"></span>    jedis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Jedis<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;192.168.230.88&#34;</span><span style="color:#f92672">,</span>6379<span style="color:#f92672">);</span>
    <span style="color:#75715e">// 2. 设置密码
</span><span style="color:#75715e"></span>    jedis<span style="color:#f92672">.</span><span style="color:#a6e22e">auth</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;132537&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">// 3. 选择库（默认是下标为0的库）
</span><span style="color:#75715e"></span>    jedis<span style="color:#f92672">.</span><span style="color:#a6e22e">select</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><strong>编写一个操作数据的方法（这里以操作String类型为例）</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testString</span><span style="color:#f92672">(){</span>
    <span style="color:#75715e">// 1.往redis中存放一条String类型的数据并获取返回结果
</span><span style="color:#75715e"></span>    String result <span style="color:#f92672">=</span> jedis<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;url&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;https://www.oz6.cn&#34;</span><span style="color:#f92672">);</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;result = &#34;</span> <span style="color:#f92672">+</span> result<span style="color:#f92672">);</span>
  
    <span style="color:#75715e">// 2.从redis中获取一条数据
</span><span style="color:#75715e"></span>    String url <span style="color:#f92672">=</span> jedis<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;url&#34;</span><span style="color:#f92672">);</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;url = &#34;</span> <span style="color:#f92672">+</span> url<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><strong>最后不要忘记编写一个释放资源的方法</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@AfterEach</span> <span style="color:#75715e">//被该注解修饰的方法会在每次执行其他方法后执行
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tearDown</span><span style="color:#f92672">(){</span>
        <span style="color:#75715e">// 1.释放资源
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>jedis <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">){</span>
            jedis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><strong>执行<code>testString()</code>方法后测试结果如图所示</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525131017888.png" alt="image-20220525131017888"></p>
</li>
</ul>
<h3 id="32jedis连接池">3.2	Jedis连接池</h3>
<hr>
<blockquote>
<p><strong>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式</strong></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">JedisConnectionFactory</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> JedisPool jedisPool<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//配置连接池
</span><span style="color:#75715e"></span>        JedisPoolConfig jedisPoolConfig <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JedisPoolConfig<span style="color:#f92672">();</span>
        jedisPoolConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">setMaxTotal</span><span style="color:#f92672">(</span>8<span style="color:#f92672">);</span>
        jedisPoolConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">setMaxIdle</span><span style="color:#f92672">(</span>8<span style="color:#f92672">);</span>
        jedisPoolConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">setMinIdle</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        jedisPoolConfig<span style="color:#f92672">.</span><span style="color:#a6e22e">setMaxWaitMillis</span><span style="color:#f92672">(</span>200<span style="color:#f92672">);</span>
        <span style="color:#75715e">//创建连接池对象
</span><span style="color:#75715e"></span>        jedisPool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> JedisPool<span style="color:#f92672">(</span>jedisPoolConfig<span style="color:#f92672">,</span><span style="color:#e6db74">&#34;192.168.230.88&#34;</span><span style="color:#f92672">,</span>6379<span style="color:#f92672">,</span>1000<span style="color:#f92672">,</span><span style="color:#e6db74">&#34;132537&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Jedis <span style="color:#a6e22e">getJedis</span><span style="color:#f92672">(){</span>
       <span style="color:#66d9ef">return</span> jedisPool<span style="color:#f92672">.</span><span style="color:#a6e22e">getResource</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

</code></pre></div><h3 id="33springdataredis介绍">3.3	SpringDataRedis介绍</h3>
<hr>
<blockquote>
<p><strong>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做<code>SpringDataRedis</code></strong></p>
<p><strong>官网地址</strong>：https://spring.io/projects/spring-data-redis</p>
</blockquote>
<ul>
<li>提供了对不同Redis客户端的整合（<code>Lettuce</code>和<code>Jedis</code>）</li>
<li>提供了<code>RedisTemplate</code>统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<blockquote>
<p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525140217446.png" alt="image-20220525140217446"></p>
<h3 id="34-springdataredis快速入门">3.4 SpringDataRedis快速入门</h3>
<hr>
<blockquote>
<p><strong><code>SpringBoot</code>已经提供了对<code>SpringDataRedis</code>的支持，使用非常简单</strong></p>
</blockquote>
<ul>
<li>
<p><strong>首先新建一个Spring Boot工程</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525141608974.png" alt="image-20220525141608974"></p>
</li>
<li>
<p><strong>然后引入连接池依赖</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;!--连接池依赖--&gt;</span>
<span style="color:#f92672">&lt;dependency&gt;</span>
    <span style="color:#f92672">&lt;groupId&gt;</span>org.apache.commons<span style="color:#f92672">&lt;/groupId&gt;</span>
    <span style="color:#f92672">&lt;artifactId&gt;</span>commons-pool2<span style="color:#f92672">&lt;/artifactId&gt;</span>
<span style="color:#f92672">&lt;/dependency&gt;</span>
</code></pre></div></li>
<li>
<p><strong>编写配置文件<code>application.yml</code>（连接池的配置在实际开发中是根据需求来的）</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml"><span style="color:#f92672">spring</span>:
  <span style="color:#f92672">redis</span>:
    <span style="color:#f92672">host</span>: <span style="color:#ae81ff">192.168.230.88</span> <span style="color:#75715e">#指定redis所在的host</span>
    <span style="color:#f92672">port</span>: <span style="color:#ae81ff">6379</span>  <span style="color:#75715e">#指定redis的端口</span>
    <span style="color:#f92672">password</span>: <span style="color:#ae81ff">132537</span>  <span style="color:#75715e">#设置redis密码</span>
    <span style="color:#f92672">lettuce</span>:
      <span style="color:#f92672">pool</span>:
        <span style="color:#f92672">max-active</span>: <span style="color:#ae81ff">8</span> <span style="color:#75715e">#最大连接数</span>
        <span style="color:#f92672">max-idle</span>: <span style="color:#ae81ff">8</span> <span style="color:#75715e">#最大空闲数</span>
        <span style="color:#f92672">min-idle</span>: <span style="color:#ae81ff">0</span> <span style="color:#75715e">#最小空闲数</span>
        <span style="color:#f92672">max-wait</span>: <span style="color:#ae81ff">100ms</span> <span style="color:#75715e">#连接等待时间</span>
</code></pre></div></li>
<li>
<p><strong>编写测试类执行测试方法</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@SpringBootTest</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedisDemoApplicationTests</span> <span style="color:#f92672">{</span>
  
  <span style="color:#a6e22e">@Resource</span>
  <span style="color:#66d9ef">private</span> RedisTemplate redisTemplate<span style="color:#f92672">;</span>
  
  <span style="color:#a6e22e">@Test</span>
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
      <span style="color:#75715e">// 1.通过RedisTemplate获取操作String类型的ValueOperations对象
</span><span style="color:#75715e"></span>      ValueOperations ops <span style="color:#f92672">=</span> redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">();</span>
      <span style="color:#75715e">// 2.插入一条数据
</span><span style="color:#75715e"></span>      ops<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;blogName&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;Vz-Blog&#34;</span><span style="color:#f92672">);</span>
  		
      <span style="color:#75715e">// 3.获取数据
</span><span style="color:#75715e"></span>      String blogName <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>String<span style="color:#f92672">)</span> ops<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;blogName&#34;</span><span style="color:#f92672">);</span>
      System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;blogName = &#34;</span> <span style="color:#f92672">+</span> blogName<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
</ul>
<h3 id="35redisserializer配置">3.5	RedisSerializer配置</h3>
<hr>
<blockquote>
<p><strong>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，<code>默认是采用JDK序列化</code>，得到的结果是这样的</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170205272.png" alt="image-20220525170205272"></p>
<p><strong>缺点：</strong></p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<blockquote>
<p><strong>那么如何解决以上的问题呢？我们可以通过自定义RedisTemplate序列化的方式来解决。</strong></p>
</blockquote>
<ul>
<li>
<p><strong>编写一个配置类<code>RedisConfig</code></strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Configuration</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedisConfig</span> <span style="color:#f92672">{</span>
  
    <span style="color:#a6e22e">@Bean</span>
    <span style="color:#66d9ef">public</span> RedisTemplate<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span>Object<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">redisTemplate</span><span style="color:#f92672">(</span>RedisConnectionFactory factory<span style="color:#f92672">){</span>
        <span style="color:#75715e">// 1.创建RedisTemplate对象
</span><span style="color:#75715e"></span>        RedisTemplate<span style="color:#f92672">&lt;</span>String <span style="color:#f92672">,</span>Object<span style="color:#f92672">&gt;</span> redisTemplate <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RedisTemplate<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#75715e">// 2.设置连接工厂
</span><span style="color:#75715e"></span>        redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">setConnectionFactory</span><span style="color:#f92672">(</span>factory<span style="color:#f92672">);</span>
  
        <span style="color:#75715e">// 3.创建序列化对象
</span><span style="color:#75715e"></span>        StringRedisSerializer stringRedisSerializer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringRedisSerializer<span style="color:#f92672">();</span>
        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> GenericJackson2JsonRedisSerializer<span style="color:#f92672">();</span>
  
        <span style="color:#75715e">// 4.设置key和hashKey采用String的序列化方式
</span><span style="color:#75715e"></span>        redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">setKeySerializer</span><span style="color:#f92672">(</span>stringRedisSerializer<span style="color:#f92672">);</span>
        redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">setHashKeySerializer</span><span style="color:#f92672">(</span>stringRedisSerializer<span style="color:#f92672">);</span>
  
        <span style="color:#75715e">// 5.设置value和hashValue采用json的序列化方式
</span><span style="color:#75715e"></span>        redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">setValueSerializer</span><span style="color:#f92672">(</span>genericJackson2JsonRedisSerializer<span style="color:#f92672">);</span>
        redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">setHashValueSerializer</span><span style="color:#f92672">(</span>genericJackson2JsonRedisSerializer<span style="color:#f92672">);</span>
  
        <span style="color:#66d9ef">return</span> redisTemplate<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><strong>此时我们已经将RedisTemplate的key设置为<code>String序列化</code>，value设置为<code>Json序列化</code>的方式，再来执行方法测试</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170925364.png" alt="image-20220525170925364"></p>
</li>
<li>
<p><strong>由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个对象</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Test</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testSaveUser</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">().</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;user:100&#34;</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> User<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Vz&#34;</span><span style="color:#f92672">,</span> 21<span style="color:#f92672">));</span>
    User user <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>User<span style="color:#f92672">)</span> redisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">().</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;user:100&#34;</span><span style="color:#f92672">);</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;User = &#34;</span> <span style="color:#f92672">+</span> user<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525171340322.png" alt="image-20220525171340322"></p>
<p>尽管Json序列化可以满足我们的需求，但是依旧存在一些问题。</p>
<p>如上图所示，为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p>
<p>那么我们如何解决这个问题呢？我们可以通过下文的<code>StringRedisTemplate</code>来解决这个问题。</p>
</li>
</ul>
<h3 id="36stringredistemplate">3.6	StringRedisTemplate</h3>
<hr>
<blockquote>
<p><strong>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172001057.png" alt="image-20220525172001057"></p>
<blockquote>
<p><strong>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程</strong></p>
</blockquote>
<ul>
<li>
<p><strong>我们可以直接编写一个测试类使用StringRedisTemplate来执行以下方法</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@SpringBootTest</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RedisStringTemplateTest</span> <span style="color:#f92672">{</span>
  
  <span style="color:#a6e22e">@Resource</span>
  <span style="color:#66d9ef">private</span> StringRedisTemplate stringRedisTemplate<span style="color:#f92672">;</span>
  
  <span style="color:#a6e22e">@Test</span>
  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testSaveUser</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> JsonProcessingException <span style="color:#f92672">{</span>
      <span style="color:#75715e">// 1.创建一个Json序列化对象
</span><span style="color:#75715e"></span>      ObjectMapper objectMapper <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectMapper<span style="color:#f92672">();</span>
      <span style="color:#75715e">// 2.将要存入的对象通过Json序列化对象转换为字符串
</span><span style="color:#75715e"></span>      String userJson1 <span style="color:#f92672">=</span> objectMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">writeValueAsString</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> User<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Vz&#34;</span><span style="color:#f92672">,</span> 21<span style="color:#f92672">));</span>
      <span style="color:#75715e">// 3.通过StringRedisTemplate将数据存入redis
</span><span style="color:#75715e"></span>      stringRedisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">().</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;user:100&#34;</span><span style="color:#f92672">,</span>userJson1<span style="color:#f92672">);</span>
      <span style="color:#75715e">// 4.通过key取出value
</span><span style="color:#75715e"></span>      String userJson2 <span style="color:#f92672">=</span> stringRedisTemplate<span style="color:#f92672">.</span><span style="color:#a6e22e">opsForValue</span><span style="color:#f92672">().</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;user:100&#34;</span><span style="color:#f92672">);</span>
      <span style="color:#75715e">// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象
</span><span style="color:#75715e"></span>      User user <span style="color:#f92672">=</span> objectMapper<span style="color:#f92672">.</span><span style="color:#a6e22e">readValue</span><span style="color:#f92672">(</span>userJson2<span style="color:#f92672">,</span> User<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
      <span style="color:#75715e">// 6.打印结果
</span><span style="color:#75715e"></span>      System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;user = &#34;</span> <span style="color:#f92672">+</span> user<span style="color:#f92672">);</span>
  <span style="color:#f92672">}</span>
  
<span style="color:#f92672">}</span>
</code></pre></div></li>
<li>
<p><strong>执行完毕回到Redis的图形化客户端查看结果</strong></p>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172508234.png" alt="image-20220525172508234"></p>
</li>
</ul>
<h3 id="37总结">3.7	总结</h3>
<hr>
<blockquote>
<p>RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。</p>
</blockquote>
<p>方案一：</p>
<ol>
<li>自定义RedisTemplate</li>
<li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li>
</ol>
<p>方案二：</p>
<ol>
<li>使用StringRedisTemplate</li>
<li>写入Redis时，手动把对象序列化为JSON</li>
<li>读取Redis时，手动把读取到的JSON反序列化为对象</li>
</ol>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
