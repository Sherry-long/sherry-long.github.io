<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sp(act)rum</title>
    <link>https://sherry-long.github.io/</link>
    <description>Recent content on Sp(act)rum</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Jan 2021 21:23:25 +0800</lastBuildDate><atom:link href="https://sherry-long.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>单链表 C实现</title>
      <link>https://sherry-long.github.io/post/linkedlist/</link>
      <pubDate>Tue, 26 Jan 2021 21:23:25 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/linkedlist/</guid>
      <description>单链表
数据结构
typedef struct LinkNode{ int data; struct LinkNode *next; }LinkNode,*LinkList; 函数：
尾插：
void List_Tinsert(LinkNode *p,int num) //尾插法 { LinkNode *s = p; while (s-&amp;gt;next) s = s-&amp;gt;next; LinkNode *r = (LinkNode *)malloc(sizeof(LinkNode)); r-&amp;gt;data = num; r-&amp;gt;next = NULL; s-&amp;gt;next = r; } 头插：
void List_Hinsert(LinkNode *p,int num) //头插法 { LinkNode *s; s = (LinkNode *)malloc(sizeof(LinkNode)); s-&amp;gt;data = num; s-&amp;gt;next = p-&amp;gt;next; p-&amp;gt;next = s; } 链表创建（从1到n按序生成）
void List_create(LinkNode *p,int n) { for(int i = 1;i &amp;lt;= n;++i) List_Tinsert(p,i); //从1到n，尾插生成  printf(&amp;#34;Creation complete!</description>
    </item>
    
    <item>
      <title>堆排序原理 &amp; C语言实现</title>
      <link>https://sherry-long.github.io/post/heapsort/</link>
      <pubDate>Tue, 26 Jan 2021 21:20:38 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/heapsort/</guid>
      <description>堆排序
首先说一下堆，它可以被视为完全二叉树，大（小）根堆即任意非根结点的值都小（大）于等于其双亲结点的值。
基本原理：建立大（小）根堆，依次将堆顶元素与堆底元素进行交换，每次交换完成后堆大小减一，重复此过程，直到数组中只剩下一个元素为止。
算法框架如下
void HeapSort(int *A,int n)	//此处预留A[0],所以参数n应为数组A的大小减1 { BuildMaxHeap(A,n);	//首先建立大根堆  for (int i = n;i &amp;gt; 1;--i) { swap(&amp;amp;A[i],&amp;amp;A[1]); HeapAdjust(A,1,i - 1); }	//每次循环将当前堆顶元素与堆底元素交换，此时堆性质可能会被破坏，  //调用HeapAdjust方法将堆重新调整有序 } 此处将A数组的第一个元素（A[0]）预留出来，后续有用 也就是说n个元素需要一个大小为n+1的数组
建立大根堆：
void BuildMaxHeap(int *A,int n) { for (int i = n / 2;i &amp;gt; 0;--i) { HeapAdjust(A,i,n); } } 很简单的几行代码，原理也很简单 学习过二叉树，我们知道：对于一个完全二叉树来说，它的最后一个节点是第 n/2（向下取整） 个节点的子节点。 比如说一个完全二叉树有五个节点，那么它的第五个节点就是第二个节点的子节点。 对以此节点为根的子树进行调整，使该子树成为堆。此后依次向前对各节点进行调整（n/2（向下取整）到1），直到根节点，使整个树成为堆。
堆调整
void HeapAdjust(int *A,int i,int n) { A[0] = A[i];	//将待调整节点值存放至A[0]中  for(int j = i * 2;j &amp;lt;= n;j *= 2)	//找到i节点的孩子节点j，并沿子节点向下调整  { if(j &amp;lt; n &amp;amp;&amp;amp; A[j] &amp;lt; A[j + 1])	//如果j有兄弟节点，并且	 j++;	//小于其兄弟节点，将j指向兄弟节点  //（也就是找到i的孩子节点中最大的那个，如果建立的是小根堆就是找到最小的那个）  if(A[j] &amp;gt; A[0]) { A[i] = A[j]; i = j; }	//如果i的孩子节点比j大，A[j]放到A[i]的位置上  //并将j作为下一个调整的节点，向下继续调整  else break;	//如果堆性质未被破坏则直接跳出循环  } A[i] = A[0];	//最终将A[i]放到它该在的地方（如堆性质未被破坏则还在原位置） } 堆排序，说白了就是将堆顶元素（最大元素）输出，将堆中的剩余元素重新调整有序，再将堆顶元素（此时为第二大元素）输出，循环此过程</description>
    </item>
    
    <item>
      <title>第二次测试</title>
      <link>https://sherry-long.github.io/post/blog2/</link>
      <pubDate>Tue, 26 Jan 2021 13:52:24 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/blog2/</guid>
      <description>this is another test</description>
    </item>
    
    <item>
      <title>测试</title>
      <link>https://sherry-long.github.io/post/blog1/</link>
      <pubDate>Tue, 26 Jan 2021 13:20:28 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/blog1/</guid>
      <description>this is a test</description>
    </item>
    
    <item>
      <title>Java笔记(持续更新)</title>
      <link>https://sherry-long.github.io/post/blog/</link>
      <pubDate>Tue, 26 Jan 2021 12:38:16 +0800</pubDate>
      
      <guid>https://sherry-long.github.io/post/blog/</guid>
      <description>此笔记为本人在复习巩固Java基础时做的记录，内容很杂，持续更新中
this关键字 创建一个对象时分以下四部： 1.分配对象空间，将对象成员变量初始化为0或空 2.执行显示值的属性初始化 3.执行构造方法 4.返回对象的地址给相关变量 this 指的是“创建好的对象的地址”，在调用构造方法时，对象已被创建，在构造方法中使用this，代表“当前对象” this 用法 1. this.name = name; 避免程序二义 2. 使用this关键字调用重载的构造方法，避免初始化代码重复。 只能在构造方法中使用，只能引用一个，必须位于构造方法的第一句 （在构造器中，如果为this添加了参数列表，那么就有不同的含义。这将产生对符合此参数列表的某个构造器的明确调用） 3. this 不能用于static方法中（因为静态方法不依赖对象来进行访问，没有对象就谈不上this） 4. this 将当前对象本身作为参数传递给其他方法 5. return this; this 将当前对象作为参数返回，这样可以对一个对象进行多次操作  static关键字 当声明一个域或方法是static时，意味着这个域或方法不与包含他的那个类的任何对象关联在一起，与类相关联 方便在没有创建对象的情况下来进行调用（方法/变量） 1. static方法： 静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的 不需要对象便可通过类名进行调用（但是也可以通过对象进行调用） 2. static变量： 静态变量被所有对象共享，在内存中只有一个副本 3. static代码块： 优化程序性能（重复代码块） private static Date startDate,endDate; static{ startDate = Date.valueOf(&amp;quot;1946&amp;quot;); endDate = Date.valueOf(&amp;quot;1964&amp;quot;); } static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的 在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 构造器是static方法，它不需要对象来调用 static不会改变方法和变量的访问权限 静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够） 可用static来实现单例模式 public class New { private static New new1 = new New(); public static New getAccess(){ return new1; } public static void main(String[] args) { System.</description>
    </item>
    
  </channel>
</rss>
